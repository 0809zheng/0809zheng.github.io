---
layout: post
title: 'Fully Convolutional Networks for Semantic Segmentation'
date: 2021-02-08
author: 郑之杰
cover: 'https://pic.imgdb.cn/item/63f32715f144a010076796d3.jpg'
tags: 论文阅读
---

> FCN: 语义分割的全卷积网络.

- paper：[Fully Convolutional Networks for Semantic Segmentation](https://arxiv.org/abs/1411.4038)

**FCN（Fully Convilutional Networks）**是语义分割领域的开山之作，相较于此前提出的**AlexNet**和**VGG**等卷积全连接的网络结构，**FCN**提出用卷积层代替全连接层来处理语义分割问题。

![](https://pic.imgdb.cn/item/63f3294ff144a010076aeec8.jpg)

**FCN**通过全卷积网络进行特征提取和下采样，通过双线性插值进行上采样，并建立一个有向无环图(**DAG**)进行特征融合。

1. 先进行5次下采样得到尺寸为输入图像$\frac{1}{32}$的特征图像；
2. 对上述特征图像进行32倍上采样得到第一张输出特征图像**FCN-32s**；
3. 结合第4次和第5次下采样的特征映射进行16倍上采样得到第二张输出特征图像**FCN-16s**；
4. 结合第3次、第4次和第5次下采样的特征映射进行8倍上采样得到第三张输出特征图像**FCN-8s**。

![](https://pic.imgdb.cn/item/63f3291af144a010076a9d6a.jpg)

特征图像**FCN-8s**相对于特征图像**FCN-32s**和特征图像**FCN-16s**，既含有丰富的语义信息，又含有丰富的空间信息，分割效果最好：

![](https://pic.downk.cc/item/5ebcd2b6c2a9a83be51bdab1.jpg)

利用**PyTorch**实现一个**FCN-8**网络。从代码中可以看到，使用了**vgg16**作为**FCN-8**的编码部分，这使得**FCN-8**具备较强的特征提取能力。

```python
import torch
import torch.nn as nn
import torch.nn.init as init
import torch.nn.functional as F

from torch.utils import model_zoo
from torchvision import models

class FCN8(nn.Module):

    def __init__(self, num_classes):
        super().__init__()

        feats = list(models.vgg16(pretrained=True).features.children())

        self.feats = nn.Sequential(*feats[0:9])
        self.feat3 = nn.Sequential(*feats[10:16])
        self.feat4 = nn.Sequential(*feats[17:23])
        self.feat5 = nn.Sequential(*feats[24:30])

        for m in self.modules():
            if isinstance(m, nn.Conv2d):
                m.requires_grad = False

        self.fconn = nn.Sequential(
            nn.Conv2d(512, 4096, 7),
            nn.ReLU(inplace=True),
            nn.Dropout(),
            nn.Conv2d(4096, 4096, 1),
            nn.ReLU(inplace=True),
            nn.Dropout(),
        )
        self.score_feat3 = nn.Conv2d(256, num_classes, 1)
        self.score_feat4 = nn.Conv2d(512, num_classes, 1)
        self.score_fconn = nn.Conv2d(4096, num_classes, 1)

    def forward(self, x):
        feats = self.feats(x)
        feat3 = self.feat3(feats)
        feat4 = self.feat4(feat3)
        feat5 = self.feat5(feat4)
        fconn = self.fconn(feat5)

        score_feat3 = self.score_feat3(feat3)
        score_feat4 = self.score_feat4(feat4)
        score_fconn = self.score_fconn(fconn)

        score = F.upsample_bilinear(score_fconn, score_feat4.size()[2:])
        score += score_feat4
        score = F.upsample_bilinear(score, score_feat3.size()[2:])
        score += score_feat3

        return F.upsample_bilinear(score, x.size()[2:])
```

在上述代码中，将**vgg16**的31个层分作5个编码模块，每个编码模块的基本结构如下所示：

```python
(0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))      
(1): ReLU(inplace=True)                                          
(2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))     
(3): ReLU(inplace=True)                                          
(4): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)   
```