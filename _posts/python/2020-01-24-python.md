---
layout: post
title: 'Python 用户笔记'
date: 2020-01-24
author: 郑之杰
cover: 'https://pic.imgdb.cn/item/640074c7f144a01007bee2e8.jpg'
tags: Python
---

> Notes about Python.

[**Python**](https://www.python.org/)是**Guido van Rossum**在**1989**年圣诞节期间，为打发无聊的圣诞节而编写的编程语言。**Python**的主要**优点**是“优雅”、“明确”、“简单”。Python的**缺点**包括：
1. **运行速度慢**：**Python**是**解释型**语言，代码在执行时会一行一行地翻译成**CPU**能理解的机器码，这个翻译过程非常耗时；而**C**语言等**编译型**语言，运行前直接编译成**CPU**能执行的机器码，所以非常快。
2. **代码不能加密**：发布**Python**程序，实际上就是发布源代码，这一点跟**C**语言不同；**C**语言不用发布源代码，只需要把编译后的机器码（也就是**Windows**上常见的**xxx.exe**文件）发布出去。

本文目录：
1. **Python**的基础语法：输入输出、
2. **Python**的数据类型：整数、浮点数、常量、变量
3. **Python**的数据结构：字符串、
4. **Python**的函数式编程：
5. **Python**的面向对象编程：
6. **Python**的模块：
7. 


# 1. Python的基础语法

**Python**使用**缩进**来组织代码块，请务必遵守约定俗成的习惯，坚持使用**4**个空格的缩进。在文本编辑器中，需要设置把**Tab**自动转换为**4**个空格，确保不混用**Tab**和空格。

## （1）输入和输出

### ⚪ 输入：`input()`
`input()`可以让用户输入**字符串**，并存放到一个变量里，返回的数据类型是**字符串str**；可以显示字符串来提示用户:

```python
name = input('please enter your name: ')

# 输入一个整数
a = int(input())

# 输入一个数组
a = input().split(" ")#以空格的方式输入。如果split(",")表示以逗号的形式输入。
li = [int(i) for i in range(a)]
```

### ⚪ 输出：`print()`
`print()`函数可以接受多个字符串，用逗号“,”隔开，依次打印每个字符串，遇到逗号“,”会输出一个**空格**：

![](https://www.liaoxuefeng.com/files/attachments/1017032122300544/l)

### 输出字符串的格式化
在Python中，输出字符串采用的格式化方式和C语言是一致的，`%`运算符就是用来格式化字符串的。有几个`%`占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个`%`，括号可以省略。格式化整数和浮点数还可以指定是否补0和整数与小数的位数：

```python
>>> print('%2d-%02d' % (3, 1))
 3-01
>>> print('%.2f' % 3.1415926)
3.14
```

常见的占位符：
- `%d`：整数
- `%f`：浮点数
- `%s`：字符串
- `%x`：十六进制整数
- `%%`：转义字符，输出`%`

另一种格式化字符串的方法是使用字符串的`format()`方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……：

```python
>>> 'Hello, {0}, 成绩提升了 {1:.1f}%'.format('小明', 17.125)
'Hello, 小明, 成绩提升了 17.1%'
```

## （2）基本运算

在Python中，有两种除法：
- `/`除法计算结果是**浮点数**，即使是两个整数恰好整除，结果也是浮点数
- 还有一种除法是`//`，称为地板除，只取结果的整数部分；所以Python还提供一个余数运算`%`，可以得到两个整数相除的余数。

## （3）控制结构

### ⚪ 条件判断
if语句的完整形式是：

```python
if <条件判断1>:
    <执行1>
elif <条件判断2>:
    <执行2>
elif <条件判断3>:
    <执行3>
else:
    <执行4>
```

### ⚪ 循环
Python的循环有两种，一种是`for...in`循环，依次把list或tuple中的每个元素迭代出来。第二种循环是`while`循环，只要条件满足，就不断循环，条件不满足时退出循环。

在循环中，`break`语句可以提前退出循环；`continue`语句跳过当前的这次循环，直接开始下一次循环。

程序陷入“死循环”，可以用**Ctrl+C**退出程序，或者强制结束**Python**进程。

### ⚪ 迭代器

判断一个对象是否可**迭代**，方法是通过**collections**模块的**Iterable**类型判断：

```python
>>> from collections import Iterable
>>> isinstance([1,2,3], Iterable) # list是否可迭代
True
>>> isinstance(123, Iterable) # 整数是否可迭代
False
```

`enumerate`函数可以把可迭代对象变成索引-元素对，这样就可以在循环中同时迭代索引和元素本身：`for i, v in enumerate([1,2,3])`

可以直接作用于for循环的对象统称为**可迭代对象Iterable**。可以使用`isinstance()`判断一个对象是否是`Iterable`对象：

```python
>>> from collections.abc import Iterable
>>> isinstance([], Iterable)
True
```

可以被`next()`函数调用并不断返回下一个值的对象称为**迭代器Iterator**。可以使用`isinstance()`判断一个对象是否是`Iterator`对象：

```python
>>> from collections.abc import Iterator
>>> isinstance((x for x in range(10)), Iterator)
True
```

生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。

把list、dict、str等Iterable变成Iterator可以使用`iter()`函数：

```python
>>> isinstance(iter('abc'), Iterator)
True
```

Python的Iterator对象表示的是一个数据流，Iterator对象可以被`next()`函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过`next()`函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。

### ⚪ 生成器
在Python中，一边循环一边计算的机制，称为**生成器generator**。

### 生成器的创建方法①

```python
>>> g = (x * x for x in range(10))
>>> g
<generator object <genexpr> at 0x1022ef630>
```

可以通过`next()`函数获得generator的下一个返回值：

```python
>>> next(g)
0
>>> next(g)
1
...
>>> next(g)
9
>>> next(g)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
```

每次调用`next(g)`，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出`StopIteration`的错误。

也可以使用for循环调用生成器：

```python
>>> g = (x * x for x in range(10))
>>> for n in g:
...     print(n)
```

### 生成器的创建方法②
如果一个函数定义中包含`yield`关键字，那么这个函数就不再是一个普通函数，而是一个generator：

```python
def odd():
    print('step 1')
    yield 1
    print('step 2')
    yield 3
```

在每次调用`next()`的时候执行，遇到`yield`语句返回，再次执行时从上次返回的`yield`语句处继续执行。

```python
>>> o = odd()
>>> next(o)
step 1
1
>>> next(o)
step 2
3
>>> next(o)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
```

也可以使用for循环调用生成器。

## （4）异常处理

在程序运行的过程中，如果发生了错误，可以事先约定返回一个错误代码，这样就可以知道是否有错，以及出错的原因。高级语言通常都内置了一套**try...except...finally...**的错误处理机制。

当某些代码可能会出错时，就可以用`try`来运行这段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即`except`语句块，执行完`except`后，如果有`finally`语句块，则执行`finally`语句块，至此，执行完毕。

错误应该有很多种类，如果发生了不同类型的错误，应该由不同的`except`语句块处理。如果没有错误发生，可以在`except`语句块后面加一个`else`，当没有错误发生时，会自动执行`else`语句。

```python
try:
    print('try...')
    r = 10 / int('2')
    print('result:', r)
except ValueError as e:
    print('ValueError:', e)
except ZeroDivisionError as e:
    print('ZeroDivisionError:', e)
else:
    print('no error!')
finally:
    print('finally...')
```

**Python**的错误其实是一个**class**，捕获一个错误就是捕获到该**class**的一个实例。所有的错误类型都继承自**BaseException**，常见的错误类型和继承关系包括[exception-hierarchy](https://docs.python.org/3/library/exceptions.html#exception-hierarchy)。

**Python**内置的**logging**模块可以非常容易地记录错误信息，把错误堆栈打印出来；程序打印完错误信息后会继续执行，并正常退出：

```python
import logging

try:
    r = 10 / 0
except Exception as e:
    logging.exception(e)
```

可以用**raise**语句抛出一个错误的实例：


```python
def foo(s):
    n = int(s)
    if n==0:
        raise ZeroDivisionError('invalid value')
    return 10 / n
```

可以用**断言（assert）**辅助检查可能有问题的变量；如果断言失败，**assert**语句本身就会抛出**AssertionError**：

```python
def foo(s):
    n = int(s)
    assert n != 0, 'n is zero!'
    return 10 / n

def main():
    foo('0')
```

启动**Python**解释器时可以用`-O`参数来关闭**assert**：

```python
$ python -O main.py
```

也可以通过`pdb.set_trace()`方法在程序中设置一个断点：

```python
# err.py
import pdb

s = '0'
n = int(s)
pdb.set_trace() # 运行到这里会自动暂停
print(10 / n)
```

运行代码，程序会自动在`pdb.set_trace()`暂停并进入**pdb**调试环境，可以用命令`p 变量名`查看变量，或者用命令`c`继续运行：

```python
$ python err.py 
> /Users/err.py(7)<module>()
-> print(10 / n)
(Pdb) p n
0
(Pdb) c
```

# 2. Python的数据类型

## （1）整数

**Python**可以处理任意大小的整数，在程序中的表示方法和数学上的写法一模一样；**Python**的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的。

有时候用十六进制表示整数比较方便，十六进制用`0x`前缀和**0-9**，**a-f**表示。

## （2）浮点数

浮点数可以用数学写法，也可以用科学计数法表示（把**10**用**e**替代）；**Python**的浮点数也没有大小限制，但是超出一定范围就直接表示为`inf`（无限大）。

整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法也是精确的），而浮点数运算则可能会有四舍五入的误差。

## （3）常量
在**Python**中，习惯上通常用全部**大写**的变量名表示常量。

布尔值和布尔代数的表示完全一致，可以用`and`、`or`和`not`运算。

空值是**Python**里一个特殊的值，用`None`表示。

## （4）变量
变量用变量名表示，变量名必须是大小写英文、数字和`_`的组合，且**不能用数字开头**。

在Python中，等号```=```是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量。

这种变量本身类型不固定的语言称之为**动态语言**，与之对应的是**静态语言**。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如**Java**是静态语言。和静态语言相比，动态语言更灵活。

理解变量在计算机内存中的表示也非常重要。如`a = 'ABC'`时，**Python**解释器干了两件事情：
1. 在内存中创建了一个`'ABC'`的字符串；
2. 在内存中创建了一个名为`a`的变量，并把它指向`'ABC'`。

解释下列代码：

```python
a = 'ABC'
b = a
a = 'XYZ'
```

![](https://pic.downk.cc/item/5eeace0f14195aa594e88075.jpg)

## （5）字符

Python中字符的编码格式如下：
- **ASCII编码**是1个字节（8个比特），包含大小写英文字母、数字和一些符号；
- **Unicode编码**把所有语言都统一到一套编码里，最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）；
- “可变长编码”**UTF-8编码**把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。

![](https://pic.downk.cc/item/5eead20d14195aa594ec1e42.jpg)

现在计算机系统通用的字符编码工作方式：
- 在计算机内存中，统一使用**Unicode**编码，当需要保存到硬盘或者需要传输的时候，就转换为**UTF-8**编码;
- 用记事本编辑的时候，从文件读取的**UTF-8**字符被转换为**Unicode**字符到内存里，编辑完成后，保存的时候再把**Unicode**转换为**UTF-8**保存到文件;
- 浏览网页的时候，服务器会把动态生成的**Unicode**内容转换为**UTF-8**再传输到浏览器.

# 3. Python的数据结构

## （1）字符串 str
字符串是以单引号`'`或双引号`"`括起来的任意文本，`''`或`""`本身只是一种表示方式，不是字符串的一部分。如果`'`本身也是一个字符，那就可以用`""`括起来，或使用转义字符`\`。

Python允许用`'''...'''`的格式表示多行内容,如：

```python
print('''Hello
World''')
```

字符串是**不可变对象**；对于不可变对象，调用对象自身的任意方法，不会改变该对象自身的内容，而是会创建新的对象并返回：

```python
>>> a = 'abc'
>>> b = a.replace('a', 'A')
>>> b
'Abc'
>>> a
'abc'
```

### ⚪ 转义字符

常见的转义字符：
- `\n`表示换行
- `\t`表示制表符
- 字符`\`本身也要转义，所以`\\`表示的字符就是`\`

Python还允许用`r''`表示`''`内部的字符串默认不转义。

### ⚪ Python的字符串编码
- Python 3版本中，字符串是以Unicode编码的.
- 对于单个字符的编码，Python提供了`ord()`函数获取字符的**整数**表示，`chr()`函数把编码转换为对应的字符
- Python对**bytes类型**的数据用带**b**前缀的单引号或双引号表示：`x = b'ABC'`，其每个字符都只占用一个字节。
- 以Unicode表示的str通过`encode()`方法可以编码为指定的bytes，例如：`'ABC'.encode('ascii')`
- 如果从网络或磁盘上读取了字节流bytes。要把bytes变为str，就需要用`decode()`方法：`b'ABC'.decode('ascii', errors='ignore')`，其中`errors='ignore'`可以忽略其中一小部分无效的字节。

当Python解释器读取源代码时，为了让它按UTF-8编码读取，通常在文件开头写上这两行：

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
```

- 第一行注释是为了告诉**Linux/OS X**系统，这是一个**Python**可执行程序，**Windows**系统会忽略这个注释；
- 第二行注释是为了告诉**Python**解释器，按照**UTF-8**编码读取源代码，否则在源代码中写的中文输出可能会有乱码。

## （2）列表 list
列表是一种有序的集合，可以随时添加和删除其中的元素。列表是**可变对象！**

- `len()`函数可以获得list元素的个数
- 用索引来访问list中每一个位置的元素，记得索引是从0开始的，还可以用-1做索引，直接获取最后一个元素；
- `.append()`方法可以往list中追加元素到末尾
- `.insert(1,)`可以把元素插入到指定的位置，比如索引号为1的位置
- 要删除list末尾的元素，用`.pop()`方法；要删除指定位置的元素，用`.pop(i)`方法，其中**i**是索引位置

### ⚪ 列表生成式 List Comprehensions
**列表生成式**是Python内置的非常简单却强大的可以用来创建list的生成式。

- 列表生成式的基础结构是**[表达式 for x in ...]**，如：

```python
>>> [x * x for x in range(1, 11)]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
```

- 列表生成式的for后面可加if作为筛选条件，不能带else：

```python
>>> [x * x for x in range(1, 11) if x % 2 == 0]
[4, 16, 36, 64, 100]
```

- 列表生成式的for前面可加if作为表达式，必须加else：

```python
>>> [x if x % 2 == 0 else -x for x in range(1, 11)]
[-1, 2, -3, 4, -5, 6, -7, 8, -9, 10]
```

- 列表生成式还可以使用两层循环，可以生成全排列：

```python
>>> [m + n for m in 'ABC' for n in 'XYZ']
['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']
```

## （3）元组 tuple
元组一旦初始化就不能修改。因为tuple不可变，所以代码更安全。tuple所谓的“不变”是说，tuple的每个元素，指向永远不变，指向的复合数据类型（如列表）本身是可变的！

要定义一个只有1个元素的tuple，如果这么定义：`t = (1)`，定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。只有1个元素的tuple定义时必须加一个逗号,，来消除歧义：`t = (1,)`。Python在显示只有1个元素的tuple时，也会加一个逗号`,`，以免误解成数学计算意义上的括号。

## （4）字典 dict
字典使用键-值（**key-value**）存储，具有极快的查找速度。**dict**的**key**必须是**不可变对象**（字符串、整数）。通过**key**计算位置的算法称为**哈希算法（Hash）**。

和**list**比较，**dict**有以下几个特点：
1. 查找和插入的速度极快，不会随着**key**的增加而变慢；
2. 需要占用大量的内存，内存浪费多。

而**list**相反：
1. 查找和插入的时间随着元素的增加而增加；
2. 占用空间小，浪费内存很少。

所以，**dict**是用空间来换取时间的一种方法。

- 字典按键迭代：`for key in dict`
- 字典按值迭代：`for value in dict.values()`
- 字典按键值对迭代：`for k, v in dict.items()`
- dict提供的`.get()`方法，如果key不存在，可以返回None，或者自己指定的value：`d.get(key, -1)`
- 要删除一个key，用`.pop()`方法，对应的value也会从dict中删除：`d.pop(key)`


## （5）集合 set
集合和**dict**类似，也是一组**key**的集合，**set**和**dict**的唯一区别仅在于没有存储对应的**value**。由于**key**不能重复，所以在**set**中没有重复的**key**。集合可以用于数据**去重**。

要创建一个set，需要提供一个list作为输入集合：`s=set([1,2,3])`。两个set可以做数学意义上的交集`&`、并集`|`等操作。
  
- 通过`.add()`方法可以添加元素到set中:`s.add(4)`
- 通过`.remove()`方法可以删除元素：`s.remove(4)`


# 4. Python的函数式编程

函数是一种最基本的代码抽象的方式。面向**过程**的程序设计：通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务。

**函数式编程Functional Programming**是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，称之为没有**副作用**。由于Python允许使用变量，因此不是纯函数式编程语言。

## （1）内置函数
可以在交互式命令行通过`help(func_name)`查看内置函数的帮助信息。

函数名其实就是指向一个函数对象的引用，可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：

```python
>>> a = abs # 变量a指向abs函数
>>> a(-1) # 所以也可以通过a调用abs函数
1
```

使用下列语句进行错误提示：

```python
if False:
    raise TypeError('there is something wrong')
```

函数执行完毕也没有`return`语句时，自动`return None`；函数可以同时返回多个值，但其实就是返回一个tuple。

常用的内置函数：
- 数据类型检查可以用内置函数`isinstance()`实现：`isinstance(x, (int, float))`

## （2）定义函数
`pass`语句什么都不做，可以用来作为**占位符**，比如现在还没想好怎么写函数的代码，就可以先放一个**pass**，让代码能运行起来。

定义函数，还需要定义参数：
- **必选参数**`def f(x)`
- **默认参数**`def f(a = 1)`：使用不可变对象，在必选参数之后，降低函数调用的难度；可以按顺序提供默认参数，当不按顺序提供部分默认参数时，需要把参数名写上。
- **可变参数**`def f(*args)`：允许传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。Python允许在list或tuple前面加一个`*`号，把list或tuple的元素变成**可变参数**传进去:```f(*list)```
- **关键字参数**`def f(**kw)`：允许传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict；可以扩展函数的功能。Python允许在dict前面加一个`**`号，把dict的元素(拷贝)变成**关键字参数**传进去:`f(**dict)`
- **命名关键字参数**`def f(*, key1, key2)`：特殊分隔符`*`后面的参数被视为命名关键字参数。如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符`*`了。命名关键字参数可以有缺省值，必须传入参数名，如果没有传入参数名，调用将报错。
- 参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。

## （3）递归函数
如果一个函数在内部调用自身本身，这个函数就是**递归函数**。递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。

使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过**栈（stack）**这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。

解决递归调用栈溢出的方法是通过**尾递归**优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。

尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。

## （4）高阶函数 Higher-order function
**高阶函数**：一个函数可以接收另一个函数作为参数。

```python
def add(x, y, f):
    return f(x) + f(y)
```

Python内置的高阶函数：
- `map()`
- `reduce()`
- `filter()`
- `sorted()`

### ⚪ `map()`
`map()`函数接收两个参数，一个是函数，一个是`Iterable`，`map`将传入的函数依次作用到序列的每个元素，并把结果作为新的`Iterator`返回。

`map()`函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫`map()`完成计算结果，有时需要用list()函数获得所有结果并返回list。

比如，把这个list所有数字转为字符串：
```python
>>> list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
['1', '2', '3', '4', '5', '6', '7', '8', '9']
```

### ⚪ `reduce()`
`reduce()`把一个函数作用在一个序列$[x1, x2, x3, ...]$上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：

```python
reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
```

例如把序列$[1, 3, 5, 7, 9]$变换成整数$13579$：

```python
>>> from functools import reduce
>>> def fn(x, y):
...     return x * 10 + y
...
>>> reduce(fn, [1, 3, 5, 7, 9])
13579
```

函数当然可以用**匿名函数lambda**的形式。

### ⚪ `filter()`
`filter()`函数用于过滤序列。接收一个函数和一个序列，把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。

如用[埃拉托色尼筛选法](https://baike.baidu.com/item/%E5%9F%83%E6%8B%89%E6%89%98%E8%89%B2%E5%B0%BC%E7%AD%9B%E9%80%89%E6%B3%95)计算质数：

```python
# 生成器生成从3开始的无限奇数序列
def _int_iter():
    n = 1
    while True:
        n += 2
        yield n
		
# 定义筛选函数
def _not_divisible(n):
    return lambda x: x%n > 0

def primes():
    yield 2  #返回第一个质数2
    it = _int_iter()  #候选无限奇数序列
    while True:
        n = next(it)
        yield n  #返回下一个质数
        it = filter(_not_divisible(n), it) #过滤这个质数的倍数
		
# 构造循环条件，使之可以输出任何范围的素数序列
for n in primes():
    if n < 1000:
        print(n)
    else:
        break
```

### ⚪ `sorted()`
`sorted()`函数也是一个高阶函数，用于对列表等进行从小到大的排序。它还可以接收一个`key`函数来实现自定义的排序，key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。

如按绝对值大小排序：

```python
>>> sorted([36, 5, -12, 9, -21], key=abs)
[5, 9, -12, -21, 36]
```
默认情况下，对字符串排序，是按照**ASCII**的大小比较的，由于**'Z' < 'a'**，结果大写字母Z会排在小写字母a的前面。

要进行反向排序，不必改动key函数，可以传入第三个参数`reverse=True`：

```python
>>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)
['Zoo', 'Credit', 'bob', 'about']
```

## （5）返回函数
高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。这种程序结构称为“**闭包（Closure）**”。

```python
def lazy_sum(args=[1, 3, 5, 7, 9]):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax
    return sum
```

在函数`lazy_sum`中又定义了函数`sum`，并且内部函数`sum`可以引用外部函数`lazy_sum`的参数和局部变量，当`lazy_sum`返回函数`sum`时，相关参数和变量都保存在返回的函数中。当我们调用`lazy_sum()`时，返回的并不是求和结果，而是求和函数：

```python
>>> f = lazy_sum(1, 3, 5, 7, 9)
>>> f
<function lazy_sum.<locals>.sum at 0x101c6ed90>
```

调用函数f时，才真正计算求和的结果：
```python
>>> f()
25
```

返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。

## （6）匿名函数
关键字`lambda x: f(x)`表示**匿名函数**，冒号前面的$x$表示函数参数。

匿名函数有个限制，就是只能有一个表达式，不用写`return`，返回值就是该表达式的结果。

用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。

匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数；或也可以把匿名函数作为返回值返回。

## （7）装饰器 decorator
假设要增强函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改函数的定义，这种在代码运行期间动态增加功能的方式，称之为**“装饰器”（Decorator）**。

### ⚪ 不带参数的decorator
本质上，decorator就是一个返回函数的高阶函数。如定义一个能打印日志的decorator:

```python
import functools

def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
```

其中Python内置的`functools.wraps`是把原始函数的`__name__`等属性复制到`wrapper()`函数中，否则，有些依赖函数签名的代码执行就会出错。

借助Python的`@`语法，把decorator置于函数的定义处：

```
@log
def func():
```

相当于执行了语句:`func = log(func)`

原来的`func()`函数仍然存在，只是现在同名的`func`变量指向了新的函数，于是调用`func()`将执行新函数，即在`log()`函数中返回的`wrapper()`函数。

`wrapper()`函数的参数定义是`(*args, **kw)`，因此，`wrapper()`函数可以接受任意参数的调用。在`wrapper()`函数内，首先打印日志，再紧接着调用原始函数。

### 带参数的decorator
带参数的decorator：

```
import functools

def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
```

和两层嵌套的decorator相比，3层嵌套的效果是这样的：`func = log('text')(func)`

上面的语句首先执行`log('text')`，返回的是decorator函数，再调用返回的函数，参数是func函数，返回值最终是wrapper函数。

## （8）偏函数
偏函数`functools.partial`的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。

如`int()`函数可以把字符串转换为整数，当仅传入字符串时，`int()`函数默认按十进制转换；`int()`函数还提供额外的`base`参数，默认值为10。如果传入`base`参数，就可以做N进制的转换:

```
>>> int('1000000', base=8)
64
```

如果多次调用该函数，每次都需要设置参数。当函数的参数个数太多，需要简化时，使用`functools.partial`可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单:

```
>>> import functools
>>> int2 = functools.partial(int, base=2)
>>> int2('1000000')
64
```

创建偏函数时，实际上可以接收函数对象、`*args`和`**kw`这3个参数。当传入：

```
max2 = functools.partial(max, 10)
```

实际上会把10作为`*args`的一部分自动加到左边，也就是：
```
max2(5, 6, 7)
```
相当于：
```
args = (10, 5, 6, 7)
max(*args)
```
结果为10。

# 5. 面向对象编程
**面向对象编程（Object Oriented Programming，OOP）**把**对象**作为程序的基本单元，一个对象包含了**数据**和操作数据的**函数**，后者称之为对象的**方法（Method）**。

在**Python**中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的**类（Class）**的概念。面向对象的设计思想是抽象出**Class**，根据**Class**创建**实例Instance**。面向对象的三大特点是数据封装、继承和多态。

在**Python**中定义类是通过**class**关键字，创建实例是通过类名**+()**实现的。在创建类的时候，可以通过`__init__`方法把一些必须绑定的**属性（attribute）**强制填写进去。

```python
class Student(object):
    # 创建类属性, 所有实例共享
    count = 0
    # __init__方法的第一个参数是self，表示创建的实例本身
    def __init__(self, name, score):
        # 创建实例属性，属于各个实例所有，互不干扰
        self.name = name
        self.score = score

# 创建实例时必须传入与__init__方法匹配的参数
# self不需要传，Python解释器自己会把实例变量传进去
bart = Student('Tom', 90)
```

可以用`type()`判断对象类型：

```python
>>> type(bart)
<class '__main__.Student'>
```

可以用`isinstance()`判断对象是否指向类型（或者位于该类型的父继承链上）：

```python
>>> isinstance(bart, Student)
True
```

也可以通过`type()`函数动态地创建类。要创建一个**class**对象，`type()`函数依次传入3个参数：
1. class的名称；
2. 继承的父类集合；
3. class的方法名称与函数绑定。

```python
>>> def fn(self, name='world'): # 先定义函数
...     print('Hello, %s.' % name)
...
>>> Hello = type('Hello', (object,), dict(hello=fn)) # 创建Hello class
```

## （1）数据封装

类是创建实例的模板，而实例则是一个一个具体的对象；**方法**是与实例绑定的函数，可以直接访问实例的数据。

通过在实例上调用方法，可以直接操作对象内部的数据，但无需知道方法内部的实现细节，这样就把“数据”给封装起来了。**数据封装**是指直接在类的内部定义访问数据的函数，外部代码可以通过直接调用实例变量的方法来操作数据，这样就隐藏了内部的复杂逻辑。

```python
class Student(object):
    def __init__(self, name, score):
        self.name = name
        self.score = score

    # 在类中定义的函数第一个参数永远是实例变量self
    # 并且调用时不用传递该参数
    def print_score(self):
        print('%s: %s' % (self.name, self.score))
```

### ⚪ 操作对象的属性和方法

如果要获得一个对象的所有属性和方法，可以使用`dir()`函数，它返回一个包含字符串的**list**：

```python
>>> dir(bart)
['__class__',..., 'name', 'print_score', 'score']
```

配合`getattr()`、`setattr()`以及`hasattr()`，可以直接操作一个对象的属性和方法：

```python
>>> hasattr(bart, 'gender') # 有属性'gender'吗？
False
>>> setattr(bart, 'gender', 'male') # 设置一个属性'gender'
>>> getattr(bart, 'gender', -1) # 获取属性'gender', 如果不存在返回默认值-1
male
```

也可以给实例绑定新的方法：

```python
>>> def set_age(self, age): # 定义一个函数作为实例方法
...     self.age = age

# 给一个实例绑定的方法，对另一个实例是不起作用的
>>> from types import MethodType
>>> bart.set_age = MethodType(set_age, bart) # 给实例绑定一个方法

# 给所有实例都绑定方法
>>> Student.set_age = set_age
```

### ⚪ 私有变量

在上述定义中，外部代码还是可以自由地修改一个实例的属性：
```python
>>> bart.score = 99
>>> bart.score
99
>>> del bart.score # 删除实例的score属性
```

如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线`__`，在**Python**中，实例的变量名如果以`__`开头，就变成了一个**私有变量（private）**，无法从外部访问。

```python
class Student(object):
    def __init__(self, name, score):
        self.__name = name
        self.__score = score
```

私有变量确保了外部代码不能随意修改对象内部的状态，这样通过访问限制的保护，代码更加健壮。如果需要访问或修改私有变量，可以增加新的方法：

```python
class Student(object):
    ...
    def get_score(self):
        return self.__score

    def set_score(self, score):
        self.__score = score
```

私有变量**__score**不能直接访问是因为**Python**解释器对外把**__score**变量改成了**_Student__score**，所以仍然可以通过**_Student__score**来访问**__score**变量。

以一个下划线开头的实例变量名比如**_score**，这样的实例变量外部是可以访问的，但是按照约定俗成的规定，请把它视为私有变量，不要随意访问。

在**Python**中，变量名类似**__xxx__**的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是**private**变量。

### ⚪ `@property`装饰器

**Python**内置的`@property`装饰器负责把类的一个方法变成属性调用。除了创建`@property`本身如果又创建了另一个装饰器`@method.setter`，则负责把一个**setter**方法变成属性赋值，从而拥有一个可控的属性操作；否则定义只读属性。

```python
class Student(object):
    @property
    def score(self):
        return self._score

    @score.setter
    def score(self, value):
        self._score = value

    @property
    def gap(self):
        return 100 - self.__score
```


## （2）继承和多态

定义一个**class**的时候，可以从某个现有的**class**继承，新的**class**称为**子类（Subclass）**，而被继承的**class**称为**基类、父类或超类（Base class、Super class）**。通常如果没有合适的继承类，就使用**object**类，这是所有类最终都会继承的类。

```python
class Teacher(Student):
    pass
```

继承后子类获得父类的全部功能。在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。当子类和父类都存在相同的方法时，子类的方法覆盖了父类的方法，在代码运行的时候，总是会调用子类的方法，这是继承的另一个好处：**多态**。

多态的好处是，当需要传入子类时，只需要接收父类类型，按照父类类型进行操作即可。对于一个变量，只需要知道它是父类类型，无需确切地知道它的子类型，就可以放心地调用相关的方法，而具体调用的方法是作用在子类对象上，由运行时该对象的确切类型决定。这就是著名的**“开闭”原则**：
- **对扩展开放**：允许新增父类的子类；
- **对修改封闭**：不需要修改依赖父类类型的函数。

动态语言的“**鸭子类型**”是指如果需要传入某类型并调用相关方法，则不一定需要传入该类型，只需要保证传入的对象有一个相关的方法就可以了。即并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。

### ⚪ 多重继承

**多重继承**使得一个子类就可以同时获得多个父类的所有功能，这种设计通常称之为**MixIn**。

```python
class Dog(Mammal, RunnableMixIn, CarnivorousMixIn):
    pass
```

**MixIn**的目的就是给一个类增加多个功能，这样在设计类的时候，优先考虑通过多重继承来组合多个**MixIn**的功能，而不是设计多层次的复杂的继承关系。

## （3）定制类

**Python**的**class**允许定义许多定制方法，可以非常方便地生成特定的类。形如`__xxx__`的变量或者函数名可用于定制类。

### ⚪ `__slots__`

**Python**允许在定义**class**的时候，定义一个特殊的`__slots__`变量，来限制该**class**实例能添加的属性：

```python
class Student(object):
    __slots__ = ('name', 'score') # 用tuple定义允许绑定的属性名称
```

`__slots__`定义的属性仅对当前类实例起作用，对继承的子类是不起作用的。

### ⚪ `__len__()`

`__len__()`方法返回长度。在**Python**中，如果调用`len()`函数试图获取一个对象的长度，实际上在`len()`函数内部，它自动去调用该对象的`__len__()`方法。

```python
>>> len('ABC')
3
>>> 'ABC'.__len__()
3
```

### ⚪ `__str__()`

`__str__()`方法能够修改显示变量，但不能修改直接敲变量打印出来的实例。

```python
>>> class Student(object):
...     def __str__(self):
...         return 'Student object'

>>> print(Student())
Student object
>>> s = Student()
>>> s
<__main__.Student object at 0x109afb310>
```

这是因为直接显示变量调用的不是`__str__()`，而是`__repr__()`，两者的区别是`__str__()`返回用户看到的字符串，而`__repr__()`返回程序开发者看到的字符串，也就是说，`__repr__()`是为调试服务的。

解决办法是再定义一个`__repr__()`。但是通常_`_str__()`和`__repr__()`代码都是一样的，所以可写为：

```python
>>> class Student(object):
...     def __str__(self):
...         return 'Student object'
...     __repr__ = __str__
```

### ⚪ `__iter__()`

如果一个类想被用于**for**循环，就必须实现一个`__iter__()`方法，该方法返回一个迭代对象，**Python**的**for**循环就会不断调用该迭代对象的`__next__()`方法拿到循环的下一个值，直到遇到**StopIteration**错误时退出循环。

```python
class Fib(object):
    def __init__(self):
        self.a, self.b = 0, 1 # 初始化两个计数器a，b

    def __iter__(self):
        return self # 实例本身就是迭代对象，故返回自己

    def __next__(self):
        self.a, self.b = self.b, self.a + self.b # 计算下一个值
        if self.a > 100000: # 退出循环的条件
            raise StopIteration()
        return self.a # 返回下一个值

>>> for n in Fib():
...     print(n)
```

### ⚪ `__getitem__()`

如果想要从一个类中按照下标取出元素，需要实现`__getitem__()`方法：

```python
class Fib(object):
    def __getitem__(self, n):
        a, b = 1, 1
        for x in range(n):
            a, b = b, a + b
        return a

>>> f = Fib()
>>> f[0]
1
```

与之对应的是`__setitem__()`方法，把对象视作list或dict来对集合赋值。还有一个`__delitem__()`方法，用于删除某个元素。


### ⚪ `__getattr__()`

`__getattr__()`方法可以动态返回一个属性。当调用不存在的属性时，比如**score**，**Python**解释器会试图调用`__getattr__(self, 'score')`来尝试获得属性：

```python
class Student(object):
    def __getattr__(self, attr):
        if attr=='score':
            return 99
```

注意到任意调用如**s.abc**都会返回**None**，这是因为定义的`__getattr__`默认返回就是**None**。

### ⚪ `__call__()`

任何类只需要定义一个`__call__()`方法，就可以直接对实例进行调用。

```python
class Student(object):
    def __call__(self):
        print('My name is Tom.')

>>> s = Student()
>>> s() # self参数不要传入
My name is Tom.
```

通过`callable()`函数可以判断一个对象是否是“可调用”对象，能被调用的对象就是一个**Callable**对象，比如函数和带有`__call__()`的类实例。

```python
>>> callable(Student())
True
```

## （4）枚举类

**Python**提供了**Enum**类来实现枚举类型的定义，其中每个常量都是**class**的一个唯一实例。

```python
from enum import Enum
Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))
```

枚举类`Month`可以直接使用`Month.Jan`来引用一个常量，或者枚举它的所有成员：

```python
for name, member in Month.__members__.items():
    print(name, '=>', member, ',', member.value)
```

既可以用成员名称引用枚举常量，又可以直接根据**value**的值获得枚举常量。**value**属性则是自动赋给成员的**int**常量，默认从**1**开始计数。如果需要更精确地控制枚举类型，可以从**Enum**派生出自定义类：

```python
from enum import Enum, unique

@unique
class Weekday(Enum):
    Sun = 0 # Sun的value被设定为0
```

`@unique`装饰器可以检查保证没有重复值。



# 6. Python的模块
模块是一组Python代码的集合，在Python中，一个.py文件就称之为一个**模块（Module）**。

使用模块最大的好处是大大提高了代码的**可维护性**。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方**引用**。我们在编写程序的时候，也经常引用其他模块，包括Python内置的模块和来自第三方的模块。

使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。但是也要注意，尽量不要与内置函数名字冲突。点[这里](https://docs.python.org/3/library/functions.html)查看Python的所有内置函数。

为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为**包（Package）**。

```
mycompany
├─ __init__.py
├─ abc.py
└─ xyz.py
```

如上面的目录结构就是一个包，`mycompany`是**顶层包名**，`abc.py`文件就是一个名字叫`abc`的模块。

每一个包目录下面都会有一个`__init__.py`的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。`__init__.py`可以是空文件，也可以有Python代码，因为`__init__.py`本身就是一个模块，而它的模块名就是顶层包名`mycompany`。

## (1)使用模块
模块的常见开头：

```
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

' a test module '

__author__ = 'Michael Liao'
```
- 第1行和第2行是标准注释，第1行注释可以让这个`hello.py`文件直接在Unix/Linux/Mac上运行，第2行注释表示.py文件本身使用标准UTF-8编码；
- 第4行是一个字符串，表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释；
- 第6行使用`__author__`变量把作者写进去，这样当你公开源代码后别人就可以瞻仰你的大名；

```
if __name__=='__main__':
    test()
```

上述两行代码表示，在命令行运行该模块文件时，Python解释器把一个特殊变量`__name__`置为`__main__`，而如果在其他地方导入该模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。

在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过`_`前缀来实现的。
- 正常的函数和变量名是公开的（public），可以被直接引用
- 类似`__xxx__`这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如`__author__`，`__name__`就是特殊变量，我们自己的变量一般不要用这种变量名；
- 类似`_xxx`和`__xxx`这样的函数或变量就是非公开的（private），不应该被直接引用。

Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。

## (2)安装第三方模块
在Python中，安装第三方模块，是通过包管理工具`pip`完成的。注意：Mac或Linux上有可能并存Python 3.x和Python 2.x，因此对应的pip命令是`pip3`。

当我们试图加载一个模块时，Python会在指定的路径下搜索对应的`.py`文件，如果找不到，就会报错：

```
>>> import mymodule
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ImportError: No module named mymodule
```

默认情况下，Python解释器会搜索**当前目录**、**所有已安装的内置模块**和**第三方模块**，搜索路径存放在`sys`模块的`path`变量中：

```
>>> import sys
>>> sys.path
['', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python36.zip', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6', ..., '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages']
```

如果我们要添加自己的搜索目录，有两种方法：

一是直接修改`sys.path`，添加要搜索的目录：
```
>>> import sys
>>> sys.path.append('/Users/michael/my_py_scripts')
```

这种方法是在运行时修改，运行结束后失效。

第二种方法是设置环境变量`PYTHONPATH`，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置`Path`环境变量类似。注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响。







