---
layout: post
title: 'LeetCode刷题指南(Python)'
date: 2020-04-01
author: 郑之杰
cover: ''
tags: LeetCode
---

> Leetcode Exercise Guidence via Python.

- [力扣（LeetCode）官网](https://leetcode.cn/)

本文目录：

一、算法篇

- 贪心算法：分配问题、区间问题
- 双指针：搜索、滑动窗口、快慢指针
- 排序算法
- 搜索算法：二分查找、深度优先搜索、回溯法、广度优先搜索
- 动态规划：一维动态规划、二维动态规划、分割问题、背包问题、股票问题
- 分治法
- 位运算
- 数学问题：数论、随机采样

二、数据结构篇

- 字符串：字符串理解、字符串比较
- 基本数据结构：数组、栈和队列、单调栈、优先队列（堆）、哈希表（字典和集合）
- 基于指针的数据结构：链表、树、图
- 其他数据结构：前缀和与积分图、并查集、设计数据结构



# 一、算法篇

## ⚪ 贪心算法

**贪心**算法（又称**贪婪**算法）是指通过选择当前状态下局部最优的操作来获得全局最优的算法。贪心算法不一定能得到全局最优解，能用贪心算法解决的问题需要满足以下条件：
- **最优子结构**：规模较大的问题的解由规模较小的子问题的解组成，规模较大的问题的解只由其中一个规模较小的子问题的解决定；
- **无后效性**：后面阶段的求解不会修改前面阶段已经计算好的结果；
- **贪心选择性质**：从局部最优解可以得到全局最优解。


### (1) 分配问题

分配问题是指以一维数组的形式给出一系列物体，要求为每个物体分配一个属性，且每个物体的属性受到其左右物体的约束；这种约束形式可能是预先指定的，也可能是通过排序施加的。


| 题目 | 题干 | 解法 |
| :---:  |  :---:  |  :---:  |
| [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/) <br> **medium** | 给一个整数数组表示某支股票每天的价格。每天可以决定是否购买和/或出售股票，返回能获得的最大利润。 | 贪心遍历每天的价格，如果价格上涨则卖出并重新购入；否则前一天就卖出。 |
| [135. 分发糖果](https://leetcode.cn/problems/candy/) <br> **easy** | 给n个具有不同评分的孩子分发糖果，相邻的孩子评分更高者获得更多糖果，求最少糖果数。 | 使用贪心左右各遍历一遍，每次遍历中只更新相邻一侧的糖果数量关系。 |
| [406. 根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/) <br> **medium** | 给定一个打乱的队列，每个人用身高$h_i$和队列前面身高大于或等于自身的人数$k_i$表示，返回未打乱的队列。 | 按身高倒序排列后贪心地按照位置$k_i$插入新列表，相同身高的人优先插入$k_i$较小者。 |
| [455. 分发饼干](https://leetcode.cn/problems/assign-cookies/) <br>  **hard** | 给定n个具有胃口值的孩子和m个具有尺寸的饼干，求最多满足的孩子数量。 | 优先给未满足孩子中最小胃口值的孩 |
| [605. 种花问题](https://leetcode.cn/problems/can-place-flowers/) <br>  **easy** | 在有一部分空地的花坛中种花，花不能种植在相邻的地块上，求最多能种多少花。 | 遍历时贪心地在左右都是空地的地块上种花。 |
| [665. 非递减数列](https://leetcode.cn/problems/non-decreasing-array/) <br> **medium** | 给定一个整数数组，判断在最多改变**1**个元素的情况下，该数组能否变成一个非递减数列。 | 遍历时贪心地改变不满足条件的两个元素($a_i>a_{i+1}$)其中一个，再判断后续是否满足条件。 |
| [870. 优势洗牌](https://leetcode.cn/problems/advantage-shuffle/) <br> **medium** | 给定两个大小相等的数组，返回数组1的任意排列，使其相对于数组2的优势最大化（满足数组1[i] > 数组2[i] 的索引 i 最大化）。 | 田忌赛马：用数组1的最小值匹配数组2的最小值；需对数组1以及数组2的下标按数值排序。 |

### (2) 区间问题

区间问题是指给定一系列区间，通过判断区间是否重叠来解决问题。

若按照区间的**左端点**进行排序，则可以求得所有重叠区间的**并集**。反之若按照区间的**右端点**进行排序，则可以求得所有重叠区间的**交集**。

上述两种过程都可以通过判断当前右端点是否超过记录的左端点来实现：

```python
n = len(alist)
alist.sort(key = lambda x: x[1]) # 按照右端点排序
right = alist[0][1]
for i in range(1, n):
    if alist[i][0] >= right: # 区间没有重叠
        right = alist[i][1]
```


| 题目 | 题干 | 解法 |
| :---:  |  :---:  |  :---:  |
| [435. 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/) <br>  **medium** | 返回需要移除区间集合中的最小区间数量，使剩余区间互不重叠。 | 将区间按照右端点排序，优先保留重叠区间中右端数值较小的区间。 |
| [452. 用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/) <br>  **medium** | 给定n个可能有重叠的气球，返回引爆所有气球所必须射出的最小弓箭数。 | 将区间按照右端点排序，合并所有具有交集的气球。 |
| [646. 最长数对链](https://leetcode.cn/problems/2-keys-keyboard/) <br> **medium** | 给定一个数对数组，构造数对链：当且仅当$b < c$时，数对$p2 = [c, d]$才可以跟在$p1 = [a, b]$后面。找出能够形成的最长数对链的长度。   | 将区间按照右端点排序，统计无重叠区间的数量。 |
| [763. 划分字母区间](https://leetcode.cn/problems/partition-labels/) <br>  **medium** | 给定一个字符串**s**，把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。 | 首先统计每个字母首次和最后出现的区间；将区间按照左端点排序，计算所有重叠区间的并集。 |


## ⚪ 双指针

**双指针**算法是指用两个指针变量在线性结构上遍历而解决问题。常见的情况包括：
- **搜索**：两个指针指向同一数组，遍历方向相同或相反；此时待搜索的数组往往是排好序的。
- **滑动窗口**：两个指针指向同一数组，遍历方向相同且不会相交；此时两个指针包围的区域即为当前的窗口。
- **快慢指针**：两个指针在链表上同向移动而解决问题。


### (1) 搜索

在相向遍历的双指针搜索中，一个初始指向最小的元素，即数组最左边，向右遍历；一个初始指向最大的元素，即数组最右边，向左遍历。

```python
l, r = 0, len(alist):
while l < r:
    if case1:
        return
    elif case2:
        l += 1
    else:
        r -= 1
```


| 题目 | 题干 | 解法 |
| :---:  |  :---:  |  :---:  |
| [75. 颜色分类](https://leetcode.cn/problems/sort-colors/) <br> **medium** | 荷兰国旗问题：对包含三个重复值$0,1,2$的数组进行原地排序。 | 使用一个指针交换$0$，使用另一个指针顺序交换$1$或者逆序交换$2$。 |
| [88. 合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array/) <br> **easy** | 合并两个非递减顺序数组，将结果存储在第一个数组中。 | 使用双指针逆序遍历两个数组。 |
| [167. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/) <br> **medium** | 给定一个非递减顺序数组，从中找出满足相加之和等于目标数的两个数。 | 使用双指针相向遍历该数组。 |
| [524. 通过删除字母匹配到字典里最长单词](https://leetcode.cn/problems/sum-of-square-numbers/) <br> **medium** | 给定一个字符串$s$和一个字符串数组，从数组中找出可以通过删除s中的某些字符得到的长度最长的字符串。 | 对字符串数组依据字符串长度的降序和字典序的升序进行排序，使用双指针分别遍历两个字符串。 |
| [633. 平方数之和](https://leetcode.cn/problems/sum-of-square-numbers/) <br> **medium** | 给定一个非负整数$c$，判断是否存在两个整数$a$和$b$使得$a^2 + b^2 = c$。 | 使用双指针相向遍历$[0,\sqrt{c}]$。 |
| [680. 验证回文串 II](https://leetcode.cn/problems/valid-palindrome-ii/) <br> **easy** | 给定一个字符串$s$，最多可以从中删除一个字符。判断$s$是否能成为回文字符串。 | 使用双指针相向遍历+贪心。 |



### (2) 滑动窗口

在滑动窗口类型的问题中都会有两个指针，一个用于「延伸」现有窗口的 $r$ 指针，和一个用于「收缩」窗口的 $l$ 指针。在任意时刻，只有一个指针运动，而另一个保持静止。

```python
l, r = 0, 0:
while r < len(alist):
    if case1:
        r += 1
    else:
        l += 1
```

| 题目 | 题干 | 解法 |
| :---:  |  :---:  |  :---:  |
| [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/) <br> **hard** | 给定两个字符串s,t，返回s中涵盖t所有字符的最小子串。 | 使用滑动窗口遍历s，使用哈希判断窗口是否包含t所有字符。 |



### (3) 快慢指针

**快慢指针（Floyd 判圈法）**适用于**链表找环路**的通用解法。给定两个指针，分别命名为 **slow** 和 **fast**，起始位置在链表的开头。每次 **fast** 前进两步，**slow** 前进一步。如果链表中存在环，则一定存在一个时刻 **slow** 和 **fast** 相遇。

设链表中环外部分的长度为 $a$。**slow** 指针进入环后，又走了 $b$ 的距离与 **fast** 相遇。此时，**fast** 指针已经走完了环的 $n$ 圈，因此它走过的总距离为 $a+b+n(b+c)$。

![](https://pic.imgdb.cn/item/640938def144a01007d7346a.jpg)

任意时刻，**fast** 指针走过的距离都为 **slow** 指针的 $2$ 倍。因此有:

$$ a+b+n(b+c) = 2(a+b) \leftrightarrow a = c+(n-1)(b+c) $$

即从相遇点到入环点的距离$c$加上 $n-1$ 圈的环长，恰好等于从链表头部到入环点的距离$a$。

因此当 **slow** 和 **fast** 第一次相遇时，将 **fast** 重新移动到链表开头，并让 **slow** 和 **fast** 每次都前进一步。最终，它们会在入环点相遇。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

def detectCycle(head: Optional[ListNode]) -> Optional[ListNode]:
    slow, fast = head.next, head.next.next
    while slow != fast:
        slow = slow.next
        fast = fast.next.next               
    fast = head
    while slow != fast:
        slow, fast = slow.next, fast.next
    return fast
```

此外快慢指针还可以用于寻找单链表中的第$\frac{n}{k}$个节点（$n$是链表长度）：慢指针一次走一步，快指针一次走$k$步，快慢指针同时出发。当快指针移动到链表的末尾时，慢指针恰好到链表的中间。

以寻找链表中间节点为例：

```python
slow, fast = head, head
while fast.next and fast.next.next:
    slow = slow.next
    fast = fast.next.next
```

| 题目 | 题干 | 解法 |
| :---:  |  :---:  |  :---:  |
| [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/) <br> **medium** | 给定一个链表的头节点，返回链表开始入环的第一个节点。  | 快慢指针，注意判断无环的情况。 |
| [148. 排序链表](https://leetcode.cn/problems/sort-list/) <br> **medium** | 给定链表的头节点，将其按升序排列并返回排序后的链表。 | 利用快慢指针找到链表中点后，可以对链表进行归并排序。 |
| [202. 快乐数](https://leetcode.cn/problems/happy-number/) <br> **easy** | 编写一个算法来判断一个数是不是快乐数。快乐数定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和；然后重复这个过程直到这个数变为1，也可能是无限循环但始终变不到1。如果这个过程结果为1，那么这个数就是快乐数。  | 对于非快乐数，快慢指针会在非1处相遇；对于快乐数，快指针会先到达1处。 |
| [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/) <br> **easy** | 给定一个单链表的头节点，判断该链表是否为回文链表。 | 先使用快慢指针找到链表中点，再把链表切成两半；然后把后半段翻转；最后比较两半是否相等。 |

## ⚪ 排序算法

常见的排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。关于这些排序算法的细节介绍请参考[<font color=blue>Python实现排序算法</font>]()。

![](https://pic.imgdb.cn/item/640bd793f144a010073a246c.png)

虽然在**python**里可以通过`alist.sort()`快速排序，而且刷题时很少需要自己手写排序算法，但是熟习各种排序算法可以加深对算法的基本理解，以及解出由这些排序算法引申出来的题目。

| 题目 | 题干 | 解法 |
| :---:  |  :---:  |  :---:  |
| [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/) <br> **medium** | 返回数组中第$k$个最大的元素。  | 快速选择算法: 只需要找到快速排序中第$k$大的枢即可，不需要对其左右再进行排序。 |
| [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/) <br> **medium** | 返回数组中出现频率前$k$高的元素。  | 使用哈希存储每个元素出现的次数，并对出现次数应用计数排序。 |
| [451. 根据字符出现频率排序](https://leetcode.cn/problems/sort-characters-by-frequency/) <br> **medium** | 给定一个字符串，根据字符出现的频率对其进行降序排序。  | 使用哈希存储每个字符出现的次数，并对出现次数应用计数排序。 |

## ⚪ 搜索算法

### (1) 二分查找

**二分查找**也常被称为二分法或者折半查找，每次查找时通过将待查找区间分成两部分并只取一部分继续查找，将查找的复杂度大大减少。对于一个长度为 $O(n)$ 的数组，二分查找的时间复杂度为 $O(\log n)$。

二分查找时区间的左右端取开区间还是闭区间在绝大多数时候都可以，尝试熟练使用一种写法，比如左闭右开（满足 **C++**、**Python** 等语言的习惯）或左闭右闭（便于处理边界条件）；如果某种写法无法跳出死循环，则考虑尝试另一种写法。

二分查找也可以看作双指针的一种特殊情况，但一般会将二者区分。双指针类型的题，指针通常是一步一步移动的；而在二分查找里，指针每次移动半个区间长度。

```python
l, r = 0, n-1
while l <= r:
#    mid = (l+r)//2
    mid = l+(r-l)//2 # 
    if alist[mid] == c:
        return True
    elif alist[mid] < c:
        l = mid + 1
    else:
        r = mid - 1
```

可以通过`bisect`库中的`bisect.bisect_left`函数实现二分查找。该函数接收一个有序数组和一个目标值，返回大于等于目标值的第一个下标(相当于**C++**中的**lower_bound**)。

```python
import bisect
idx = bisect.bisect_left(alist, target)
if idx < len(alist) and alist[idx] == target:
    return True
return False
```

| 题目 | 题干 | 解法 |
| :---:  |  :---:  |  :---:  |
| [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/) <br> **medium** | 给定一个按照非递减顺序排列的整数数组和一个目标值，找出给定目标值在数组中的开始位置和结束位置。  | 两次二分查找分别搜索起止位置。 |
| [69. x 的平方根](https://leetcode.cn/problems/sqrtx/) <br> **easy** | 返回非负整数 $x$ 的算术平方根的整数部分。  | 二分查找区间$[0,x]$。 |
| [81. 搜索旋转排序数组 II](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/) <br> **medium** | 对一个非降序排列的整数数组在某个下标上进行旋转，判断给定的目标值是否存在于数组中。   | 二分查找时若不能确定左右区间，则可以简单地将左端点右移一位。 |
| [154. 寻找旋转排序数组中的最小值 II](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/) <br> **hard** | 对一个非降序排列的整数数组在某个下标上进行旋转，找出数组中的最小元素。   | 思路同**81**。 |
| [540. 有序数组中的单一元素](https://leetcode.cn/problems/single-element-in-a-sorted-array/) <br> **medium** | 给定一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。找出只出现一次的数。   | 二分查找奇数长度区间。 |

### (2) 深度优先搜索

**深度优先搜索（depth-first search，DFS）**在搜索到一个新的节点时，立即对该新节点进行遍历；对于树结构而言，由于总是对新节点调用遍历，因此看起来是向着“深”的方向前进。

**DFS**遍历需要用先入后出的**栈（stack）**来实现，也可以通过与栈等价的**递归**来实现。但因为栈与递归的调用原理相同，而递归相对便于实现，因此刷题时推荐使用递归式写法，同时也方便进行回溯。不过在实际工程上，直接使用栈可能才是最好的选择，一是因为便于理解，二是更不易出现递归栈满的情况。

有时我们可能会需要对已经搜索过的节点进行标记，以防止在遍历时重复搜索某个节点，这种做法叫做**状态记录**或**记忆化（memoization）**。

深度优先搜索类型的题可以分为主函数和辅函数，**主函数**用于遍历所有的搜索位置，判断是否可以开始搜索，如果可以即在辅函数进行搜索。**辅函数**则负责深度优先搜索的递归调用。

在辅函数内进行递归搜索时，需要注意**边界条件**的判定。边界判定一般有两种写法，一种是先判定是否越界，只有在合法的情况下才进行下一步搜索（即判断放在调用递归函数前）；另一种是先进行下一步搜索，待下一步搜索开始时再判断是否合法（即判断放在辅函数第一行）。

一般地，使用**DFS**遍历$m \times n$的$0/1$二维数组中所有值为$1$的连通域的写法如下：

```python
def solve(matrix):
    m, n = len(matrix), len(matrix[0])
    # 状态记录
    visited = set()


    # 写法①：先判定边界条件再进行搜索
    def dfs(i, j):
        visited.add((i,j))
        for di,dj in [(-1,0), (1,0), (0,-1), (0,1)]:
            new_i, new_j = i+di, j+dj
                if (0<=new_i<m) and (0<=new_j<n) and (new_i, new_j) not in visited and matrix[new_i][new_j] == 1:
                    dfs(new_i, new_j)  
                    
    for i in range(m):
        for j in range(n):
            if matrix[i][j]==1 and (i, j) not in visited:
                dfs(i, j)


    # 写法②：先搜索再判定边界条件
    def dfs(i, j):
        if (i<0 or i>=m) or (j<0 or j>=n) or (i, j) in visited or matrix[i][j] == 0:
            return
        visited.add((i,j))
        for di,dj in [(-1,0), (1,0), (0,-1), (0,1)]:
            dfs(i+di, j+dj)  
                    
    for i in range(m):
        for j in range(n):
            dfs(i, j)
```


| 题目 | 题干 | 解法 |
| :---:  |  :---:  |  :---:  |
| [130. 被围绕的区域](https://leetcode.cn/problems/surrounded-regions/) <br> **medium** | 找到由字符'X'和'O'组成的矩阵中所有被'X'围绕的区域，并将这些区域里所有的'O'用'X'填充。  | 使用深度优先搜索沿矩阵边缘搜索'O'，并填充未被搜索到的'O'。 |
| [257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/) <br> **easy** | 按任意顺序返回二叉树所有从根节点到叶子节点的路径。  | 使用深度优先搜索，遍历树的所有节点。 |
| [417. 太平洋大西洋水流问题](https://leetcode.cn/problems/pacific-atlantic-water-flow/) <br> **medium** | 雨水只能从高向低流，求矩阵中哪些坐标的雨水既可以流入太平洋（左上）又可以流入大西洋（右下）。  | 使用深度优先搜索实现反向搜索，求两次搜索的交集。 |
| [547. 省份数量](https://leetcode.cn/problems/number-of-provinces/) <br> **medium** | 返回矩阵中省份的数量，省份是一组直接或间接相连的城市，组内不含其他没有相连的城市。  | 深度优先搜索，计算图中的连通分量数。 |
| [695. 岛屿的最大面积](https://leetcode.cn/problems/max-area-of-island/) <br> **medium** | 计算最大的岛屿面积，岛屿的面积是岛上值为 $1$ 的单元格的数目，在水平或者竖直的四个方向上相邻。  | 深度优先搜索，在辅函数中记录面积并返回。 |

### (3) 回溯法

**回溯法（backtracking）**是优先搜索的一种特殊情况，又称为试探法，常用于需要记录节点状态的深度优先搜索。通常来说，排列、组合、选择类问题使用回溯法比较方便。

回溯法的核心是**回溯**。在搜索到某一节点的时候，如果我们发现目前的节点（及其子节点）并不是需求目标时，我们回退到原来的节点继续搜索，并且把在目前节点修改的状态**还原**。这样的好处是我们可以始终只对图的总状态进行修改，而非每次遍历时新建一个图来储存状态。

在具体的写法上，它与普通的深度优先搜索一样，都有 [修改当前节点状态]→[递归子节点] 的步骤，只是多了回溯的步骤，变成了 [修改当前节点状态]→[递归子节点]→[回改当前节点状态]。

回溯法修改一般有两种情况，一种是修改最后一位输出，比如排列组合；一种是修改访问标记，比如矩阵里搜字符串。回溯法的两个小诀窍：一是按引用传状态，二是所有的状态修改在递归完成后回改。

以全排列的顺序访问$n$个元素的数组`nums`的写法：
```python
def solve(nums):
    n = len(nums)
    # 状态记录
    visited = set()

    def backtrack():
        if len(state) == n:
            # state所指向的列表在深度优先遍历的过程中只有一份
            # 在进行值传递的过程中需要做一次拷贝
            res.append(state[:])
            return
        for j in range(n):
            if i not in visited:
                # 修改当前节点状态
                visited.add(j)
                state.append(nums[j])
                # 递归子节点
                backtrack(state)
                # 回改当前节点状态
                visited.remove(j)
                state.pop()
                
    for i in range(n):
        # 设置初始状态，这一步也可以合并到递归函数中
        state = [nums[i]]
        visited.add(i)
        backtrack()
        visited.remove(i)
```

| 题目 | 题干 | 解法 |
| :---:  |  :---:  |  :---:  |
| [37. 解数独](https://leetcode.cn/problems/sudoku-solver/) <br> **hard** | 通过填充空格来解决数独问题。  | 回溯，遍历所有待求解位置，使用标识符判断是否解完。 |
| [40. 组合总和 II](https://leetcode.cn/problems/combination-sum-ii/) <br> **medium** | 找出集合中所有可以使数字和为目标数的组合。集合中的每个数字在每个组合中只能使用一次。  | 回溯，状态设置为当前和，使用哈希统计重复数字以去重。 |
| [46. 全排列](https://leetcode.cn/problems/permutations/) <br> **medium** | 返回一个不含重复数字的数组的所有可能的全排列。  | 回溯，状态设置为当前数组的长度。 |
| [47. 全排列 II](https://leetcode.cn/problems/permutations-ii/) <br> **medium** | 返回一个可包含重复数字的数组的所有不重复的全排列。  | 回溯，状态设置为当前数组的长度，在同一位置上需要去重。 |
| [51. N 皇后](https://leetcode.cn/problems/n-queens/) <br> **hard** | **n** 皇后问题研究的是如何将 **n** 个皇后放置在 **n×n** 的棋盘上，并且使皇后彼此之间不能相互攻击。皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。  | 每个皇后必须位于不同行和不同列。回溯，状态设置为当前行。使用集合记录冲突的列、左斜线(行列下标之和)和右斜线(行列下标之差)。 |
| [77. 组合](https://leetcode.cn/problems/combinations/) <br> **medium** | 返回范围 $[1, n]$ 中所有可能的 $k$ 个数的组合。  | 回溯，状态设置为当前数组的长度。 |
| [79. 单词搜索](https://leetcode.cn/problems/word-search/) <br> **medium** | 给定一个二维字符网格和一个字符串单词，判断单词是否存在于网格中。  | 回溯，状态设置为单词的当前搜索位置。 |

### (4) 广度优先搜索

**广度优先搜索（breadth-first search，BFS）**不同于深度优先搜索，它是一层层进行遍历的，因此需要用先入先出**的队列**进行遍历。由于是按层次进行遍历，广度优先搜索时按照“广”的方向进行遍历，也常常用来处理**最短路径**等问题。

深度优先搜索和广度优先搜索都可以处理**可达性**问题，即从一个节点开始是否能达到另一个节点。因为深度优先搜索可以利用递归快速实现，很多人会习惯使用深度优先搜索刷此类题目。实际软件工程中很少见到递归的写法，因为一方面难以理解，另一方面可能产生栈溢出的情况；而用栈实现的深度优先搜索和用队列实现的广度优先搜索在写法上并没有太大差异，因此使用哪一种搜索方式需要根据实际的功能需求来判断。

在最短路问题中，如果要求多个源点出发的最短路时，一般我们都会建立一个「**超级源点**」连向所有的源点，用「超级源点」到终点的最短路等价多个源点到终点的最短路。

一般地，使用**BFS**遍历$m \times n$的$0/1$二维数组中所有值为$1$的连通域的写法如下：

```python
def solve(matrix):
    m, n = len(matrix), len(matrix[0])
    # 建立队列
    from collections import deque
    queue = deque([])
    # 状态记录
    visited = set()

    for i in range(m):
        for j in range(n):
            if (i,j) not in visited and grid[x][y]==1:
                queue.append((i,j))
                while queue:
                    x, y = queue.popleft()
                    if x<0 or x>=m or y<0 or y>=n or (x,y) in visited:
                        continue
                    visited.add((x,y))
                    for (dx, dy) in [(-1,0), (1,0), (0,-1), (0,1)]:
                        queue.append((x+dx, y+dy))
```

| 题目 | 题干 | 解法 |
| :---:  |  :---:  |  :---:  |
| [310. 最小高度树](https://leetcode.cn/problems/minimum-height-trees/) <br> **medium** | 找到一个无向无环图中所有的最小高度树，并按任意顺序返回它们的根节点标签列表。  | 最小高度树的根节点一定是图中的最长路径的中间节点。首先以任意节点$p$出发通过**BFS**找到最远终点$x$，再从$x$出发找到最远终点$y$，则$x\to y$为最远路径。 |
| [542. 01 矩阵](https://leetcode.cn/problems/01-matrix/) <br> **medium** | 给定一个由 0 和 1 组成的矩阵，请输出一个大小相同的矩阵，其中每一个格子是矩阵中对应位置元素到最近的 0 的距离。  | 从所有0元素开始**BFS**，每找到一个新位置距离加1。 |
| [934. 最短的桥](https://leetcode.cn/problems/shortest-bridge/) <br> **medium** | 求最少要填海造陆($0\to 1$)多少个位置才可以将个二维 **0-1** 矩阵中两个由**1**组成的岛屿相连。  | 第一次**DFS**或**BFS**搜索第一座岛并记录边缘位置，第二次**BFS**从边缘位置开始搜索。 |

## ⚪ 动态规划

**动态规划（Dynamic Programming, DP）**是将原问题拆成多个**重叠子问题**进行求解。为了避免重复求解子问题，动态规划保存子问题的解，避免重复计算。动态规划只能应用于有**最优子结构**的问题，即局部最优解能决定全局最优解。

解决动态规划问题的关键是找到**状态转移方程**，以便于通过计算和储存子问题的解来求解最终问题。同时也可以对动态规划进行**空间压缩**，起到节省空间消耗的效果；一种常用的空间压缩方法是**滚动数组**，相比于直接存储所有的$n$个状态，若状态转移方程中当前状态只与前面$k<n$个状态有关，则只使用$k$个变量来存储之前的状态。

动态规划可以看成是带有**状态记录（memoization）**的优先搜索。状态记录是指如果一个子问题在优先搜索时已经计算过一次，则可以把它的结果储存下来，之后遍历到该子问题时直接返回储存的结果。

动态规划是自下而上的，即先解决子问题，再解决父问题；而带有状态记录的优先搜索是自上而下的，即从父问题搜索到子问题，若重复搜索到同一个子问题则进行状态记录，防止重复计算。

如果题目需求的是最终状态，那么使用动态规划比较方便；如果题目需要输出所有的路径，那么使用带有状态记录的优先搜索会比较方便。

一般地，动态规划的求解思路：
1. **状态定义：** $dp[i]$
2. 列出**转移方程：** $dp[i+1] = f(dp[i],dp[i-1],...)$
3. 给定**边界条件：** $dp[0]$
4. **返回值：** $dp[n]$

### (1) 一维动态规划

以斐波那契数列$\left( f(n)=f(n-1)+f(n-2) \right)$为例，**1D DP**的写法如下

```python
 def dp1D(n):
     p0, p1 = 0, 1
     for i in range(2,n+1):
         p2 = p0 + p1
         p0, p1 = p1, p2
     return p1
```

| 题目 | 题干 | 解法 |
| :---:  |  :---:  |  :---:  |
| [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/) <br> **medium** | 找出一个整数数组中具有最大和的连续子数组，返回其最大和。  | $$ \begin{aligned} \text{状态定义：} & dp[i] \text{为以元素i为结尾的子数组的最大和} \\ \text{转移方程：} & dp[i] = \max(dp[i-1], 0) + alist[i] \\ \text{边界条件：} & dp[1]=alist[0] \\ \text{返回值：} & \max(dp)  \\ \text{空间压缩：} & \text{使用长度为1的滚动数组} \end{aligned} $$ |
| [70. 爬楼梯](https://leetcode.cn/problems/minimum-height-trees/) <br> **easy** | 每次可以爬 1 或 2 个台阶，有多少种不同的方法可以爬到n 阶楼顶呢？  | $$ \begin{aligned} \text{状态定义：} & dp[i] \text{为爬到第 i 级台阶的方案数} \\ \text{转移方程：} & dp[i] = dp[i-1]+dp[i-2] \\ \text{边界条件：} & dp[0]=1,dp[1]=1 \\ \text{返回值：} & dp[n]  \\ \text{空间压缩：} & \text{使用长度为3的滚动数组} \end{aligned} $$ |
| [91. 解码方法](https://leetcode.cn/problems/decode-ways/) <br> **medium** | 给定一个数字字符串，计算解码方法的总数，解码是指把数字1到26映射为字母A到Z。  | $$ \begin{aligned} \text{状态定义：} & dp[i] \text{为以第 i 个字符结尾的解码方法的总数} \\ \text{转移方程：} & dp[i] = \mathbb{I}(str[i] \in ['1':'9'])dp[i-1]+\mathbb{I}(str[i-1:i+1] \in ['10':'26'])dp[i-2] \\ \text{边界条件：} & dp[0]=1 ,dp[1]=\mathbb{I}(str[0] \in ['1':'9']) \\ \text{返回值：} & dp[n]  \end{aligned} $$ |
| [198. 打家劫舍](https://leetcode.cn/problems/house-robber/) <br> **medium** | 小偷计划偷窃沿街的房屋，不能偷窃相邻的房屋，求能够偷窃到的最高金额。 | $$ \begin{aligned} \text{状态定义：} & dp[i] \text{为到达第 i 间房能偷窃到的最高金额} \\ \text{转移方程：} & dp[i] = \max(dp[i-1], dp[i-2]+alist[i]) \\ \text{边界条件：} & dp[0]=0,dp[1]=alist[0] \\ \text{返回值：} & dp[n]  \\ \text{空间压缩：} & \text{使用长度为3的滚动数组} \end{aligned} $$ |
| [213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/) <br> **medium** | 小偷计划偷窃沿街的房屋，不能偷窃相邻的房屋，求能够偷窃到的最高金额。第一个房屋和最后一个房屋是紧挨着的。 | $$ \begin{aligned} \text{状态定义：} & dp0[i],dp1[i] \text{分别为不偷窃和偷窃第一间房，到达第 i 间房能偷窃到的最高金额} \\ \text{转移方程：} & dp0[i] = \max(dp0[i-1], dp0[i-2]+alist[i]),i=2:n \\ & dp1[i] = \max(dp1[i-1], dp1[i-2]+alist[i]),i=1:n-1 \\ \text{边界条件：} & dp0[0]=0 ,dp1[0]=0 \\ \text{返回值：} & \max(dp0[n], dp1[n-1]) \end{aligned} $$ |
| [413. 等差数列划分](https://leetcode.cn/problems/arithmetic-slices/) <br> **medium** | 返回数组中所有为等差数组的子数组个数，等差数列至少有三个元素。 | $$ \begin{aligned} \text{状态定义：} & dp[i] \text{为以第 i 个元素为结尾的等差数列的数量} \\ \text{转移方程：} & dp[i] = \begin{cases} dp[i-1]+1, & alist[i]-alist[i-1]=alist[i-1]-alist[i-2] \\ 0, & \text{otherwise} \end{cases} \\ \text{边界条件：} & dp[0]=0,dp[1]=0,dp[2]=0 \\ \text{返回值：} & sum(dp)  \\ \text{空间压缩：} & \text{使用长度为2的滚动数组} \end{aligned} $$ |



### (2) 二维动态规划

| 题目 | 题干 | 解法 |
| :---:  |  :---:  |  :---:  |
| [10. 正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/) <br> **hard** | 给定一个字符串和一个字符规律，实现一个支持'.'（匹配任意单个字符）和'*'（匹配零个或多个前面的那一个元素）的正则表达式匹配。 | $$ \begin{aligned} \text{状态定义：} & dp[i][j] \text{表示s[0:i]能否被p[0:j]匹配} \\ \text{转移方程：} & dp[i][j] = \begin{cases} p[j]='*' \begin{cases} dp[i][j-2], &  !match(s[i],p[j-1]) \\ dp[i][j-2] \text{ or } dp[i-1][j], & match(s[i],p[j-1])  \end{cases} \\ p[j]!='*' \begin{cases} False, &  !match(s[i],p[j-1]) \\ dp[i-1][j-1] , & match(s[i],p[j-1])  \end{cases}  \end{cases} \\ \text{边界条件：} & dp[0][0]=True \\ \text{返回值：} & dp[m][n] \end{aligned} $$ |
| [64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/) <br> **medium** | 找出矩阵一条从左上角到右下角的路径，使得路径上的数字总和为最小，每次只能向下或者向右移动一步。  | $$ \begin{aligned} \text{状态定义：} & dp[i][j] \text{为到达位置(i,j)的最小路径和} \\ \text{转移方程：} & dp[i][j] = \begin{cases} grid[i][j]+dp[i][j-1], & i =0\\ grid[i][j]+dp[i-1][j], & j =0\\  grid[i][j]+\min(dp[i][j-1], dp[i-1][j]), & \text{otherwise} \end{cases} \\ \text{边界条件：} & dp[0][0]=alist[0][0] \\ \text{返回值：} & dp[m-1][n-1] \\ \text{空间压缩：} & \text{用}dp[j]\text{代表}dp[i][j]  \end{aligned} $$ |
| [72. 编辑距离](https://leetcode.cn/problems/edit-distance/) <br> **hard** | 返回将word1转换成word2所使用的最少操作数，操作包括插入、删除、替换一个字符。  | $$ \begin{aligned} \text{状态定义：} & dp[i][j] \text{为把word1[0:i]替换为word2[0:j]所使用的最少操作数} \\ \text{转移方程：} & dp[i][j] = \begin{cases} dp[i-1][j-1], &  word1[i]=word2[j] \\ \min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])+1, & \text{otherwise}  \end{cases} \\ \text{边界条件：} & dp[i][0]=i,dp[0][j]=j \\ \text{返回值：} & dp[m][n] \end{aligned} $$ |
| [221. 最大正方形](https://leetcode.cn/problems/maximal-square/) <br> **medium** | 在一个由 '0' 和 '1' 组成的二维矩阵内，计算只包含 '1' 的最大正方形的面积。  | $$ \begin{aligned} \text{状态定义：} & dp[i][j] \text{为以位置(i,j)为右下角的正方形最大边长} \\ \text{转移方程：} & dp[i][j] = \min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1 \\ \text{边界条件：} & dp[i][0]=1 \text{ if } alist[i][0]=\text{'1'} , dp[0][j]=1 \text{ if } alist[0][j]=\text{'1'} \\ \text{返回值：} & [\max(dp)]^2  \end{aligned} $$ |
| [312. 戳气球](https://leetcode.cn/problems/burst-balloons/) <br> **hard** | 有 n 个气球，戳破第 i 个气球可以获得**nums[i - 1] * nums[i] * nums[i + 1]**枚硬币。求戳破所有的气球所能获得硬币的最大数量。  | $$ \begin{aligned} \text{状态定义：} & dp[i][j] \text{表示填满开区间 (i,j) 能得到的最多硬币数} \\ \text{转移方程：} & dp[i][j] = \begin{cases} \mathop{\max}_{i<k<j}(nums[i]*nums[k]*nums[j]+dp[i][k]+dp[k][j]), & i+1<j \\ 0, & i+1 \geq j  \end{cases} \\ \text{边界条件：} & dp[i][j]=0 \\ \text{返回值：} & dp[0][n+1]  \end{aligned} $$ |
| [542. 01 矩阵](https://leetcode.cn/problems/01-matrix/) <br> **medium** | 给定一个由 0 和 1 组成的矩阵，请输出一个大小相同的矩阵，其中每一个格子是矩阵中对应位置元素到最近的 0 的距离。  | $$ \begin{aligned} \text{状态定义：} & dp[i][j] \text{为位置(i,j)到最近的0的距离} \\ \text{转移方程：} & i=0:m;j=0:n \quad dp[i][j] = 1+\min(dp[i-1][j], dp[i][j-1]) \\ & i=m:0;j=n:0 \quad dp[i][j] = 1+\min(dp[i+1][j], dp[i][j+1]) \\ \text{边界条件：} & dp[i][j]=0 \text{ if } alist[i][j]=0 \\ \text{返回值：} & dp \\ \text{空间压缩：} & \text{两次动态搜索即可完成四个方向上的查找}  \end{aligned} $$ |
| [583. 两个字符串的删除操作](https://leetcode.cn/problems/delete-operation-for-two-strings/) <br> **medium** | 给定两个单词，每步可以删除任意一个字符串中的一个字符，返回使得两个单词相同所需的最小步数。  | $$ \begin{aligned} \text{状态定义：} & dp[i][j] \text{表使得word1[0:i]和word2[0:j]相同所需的最小步数} \\ \text{转移方程：} & dp[i][j] = \begin{cases} dp[i-1][j-1], & word1[i]=word2[j] \\ \min(dp[i-1][j], dp[i][j-1])+1, & word1[i]\neq word2[j]  \end{cases} \\ \text{边界条件：} & dp[i][0]=i,dp[0][j]=j \\ \text{返回值：} & dp[m][n] \end{aligned} $$ |
| [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/) <br> **medium** | 返回两个字符串的最长公共子序列（不一定连续）的长度。  | $$ \begin{aligned} \text{状态定义：} & dp[i][j] \text{为str1[0:i]和str2[0:j]的最长公共子序列长度} \\ \text{转移方程：} & dp[i][j] = \begin{cases} dp[i-1][j-1]+1, &  str1[i]=str2[j] \\ \max(dp[i-1][j],dp[i][j-1]), & \text{otherwise}  \end{cases} \\ \text{边界条件：} & dp[i][0]=0,dp[0][j]=0 \\ \text{返回值：} & dp[m][n]  \end{aligned} $$ |


### (3) 分割问题

对于分割类型的问题，动态规划的状态转移方程通常并不依赖相邻的位置，而是依赖于满足**分割条件**的位置。

对于分割问题，当遍历到某个状态$i$时，往往需要状态$i$之前的所有状态$j<i$，对于满足分割条件的状态进行计算；总时间复杂度一般为$O(N^2)$。

```python
def seg(alist):
    n = len(alist)
    dp = [0]*(n+1)
    dp[1] = init
    for i in range(2, n+1):
        for j in range(1, i):
            if cond(alist[i], alist[j]):
                dp[i] = f(dp[j])
```

| 题目 | 题干 | 解法 |
| :---:  |  :---:  |  :---:  |
| [139. 单词拆分](https://leetcode.cn/problems/word-break/) <br> **medium** | 给定一个字符串和一个字符串列表作为字典，判断是否可以利用字典中出现的单词拼接出字符串。  | $$ \begin{aligned} \text{状态定义：} & dp[i] \text{为字符串前 i 个字符能否用字典拼接} \\ \text{分割条件：} & \text{字典内的字符串} \\ \text{转移方程：} & dp[i] = \begin{cases} 1, & \exist \text{ word}, s[i-\text{len(word)}:i]=\text{word and }dp[i-\text{len(word)}]=1 \\ 0, & \text{otherwise}  \end{cases} \\ \text{边界条件：} & dp[0]=1 \\ \text{返回值：} & dp[n]==1  \\ \text{空间压缩：} & \text{把字符串列表存储为哈希(key:字符串长度; value:字符串集合)} \end{aligned} $$ |
| [264. 丑数 II](https://leetcode.cn/problems/ugly-number-ii/) <br> **medium** | 给定一个整数n，找出第n个丑数，丑数是只包含质因数 2、3 和/或 5 的正整数。 | $$ \begin{aligned} \text{状态定义：} & dp[i] \text{表示第i个丑数} \\  \text{分割条件：} & p2,p3,p5\text{表示下一个丑数是当前指针指向的丑数乘以对应的质因数}  \\ & \text{更新后需要将数值等于当前丑数的指针后移1位}  \\  \text{转移方程：} & dp[i] = \mathop{\min}_{p2,p3,p5}\left( dp[p2]*2, dp[p3]*3, dp[p5]*5\right)  \\ \text{边界条件：} & dp[1]=1 \\ \text{返回值：} & dp[n] \end{aligned} $$ |
| [279. 完全平方数](https://leetcode.cn/problems/perfect-squares/) <br> **medium** | 返回和为 n 的完全平方数的最少数量。  | $$ \begin{aligned} \text{状态定义：} & dp[i] \text{为和为 i 的完全平方数的最少数量} \\ \text{分割条件：} & \text{所有不超过 i 的完全平方数} \\ \text{转移方程：} & dp[i] = \min_{k=1:\lfloor \sqrt{i} \rfloor}(dp[i-k^2])+1 \\ \text{边界条件：} & dp[0]=0 \\ \text{返回值：} & dp[n] \end{aligned} $$ |
| [300. 最长递增子序列](https://leetcode.cn/problems/perfect-squares/) <br> **medium** | 给定一个整数数组，找到其中最长严格递增子序列(不一定连续)的长度。  | $$ \begin{aligned} \text{状态定义：} & dp[i] \text{为以第 i 个数结尾的最长递增子序列长度} \\ \text{分割条件：} & \text{两个数的大小关系} \\ \text{转移方程：} & dp[i] = \begin{cases} \max_{k<i} \left( dp[k] \right)+1, & alist[k]<alist[i] \\ 1, & \text{otherwise}  \end{cases} \\ \text{边界条件：} & dp[1]=1 \\ \text{返回值：} & \max(dp)  \end{aligned} $$ |
| [313. 超级丑数](https://leetcode.cn/problems/super-ugly-number/) <br> **medium** | 超级丑数是一个正整数，并满足其所有质因数都出现在质数数组primes中，返回第n个超级丑数。 | $$ \begin{aligned} \text{状态定义：} & dp[i] \text{表示第i个丑数} \\  \text{分割条件：} & p[j]\text{表示下一个丑数是当前指针j指向的丑数乘以对应的质因数primes[j]}  \\ & \text{更新后需要将数值等于当前丑数的指针后移1位}  \\  \text{转移方程：} & dp[i] = \mathop{\min}_{j}\left( dp[p[j]]*primes[j]\right)  \\ \text{边界条件：} & dp[1]=1 \\ \text{返回值：} & dp[n] \end{aligned} $$ |
| [343. 整数拆分](https://leetcode.cn/problems/integer-break/) <br> **medium** | 给定一个正整数，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。  | $$ \begin{aligned} \text{状态定义：} & dp[i] \text{表示将i拆分成至少两个正整数的和之后的最大乘积} \\ \text{分割条件：} & 1 \leq j <i \\ \text{转移方程：} & dp[i] = \mathop{\max}_{j}\left( \max(j\times (i-j), j\times dp[i-j]) \right) \\ \text{边界条件：} & dp[1]=1 \\ \text{返回值：} & dp[n] \\ \text{空间压缩：} & j \leq 3 \end{aligned} $$ |
| [376. 摆动序列](https://leetcode.cn/problems/wiggle-subsequence/) <br> **medium** | 返回数组中作为摆动序列的最长子序列（不一定连续）的长度。如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。  | $$ \begin{aligned} \text{状态定义：} & dp[i][0],dp[i][1] \text{表示以第i个数结尾的最长摆动子序列长度} \\ & dp[i][0]\text{表示第i个数呈下降趋势, }dp[i][1]\text{表示第i个数呈上升趋势} \\  \text{分割条件：} & nums[j]<nums[i], nums[k]>nums[i] \\ \text{转移方程：} & dp[i][0] = \mathop{\max}_{k:nums[k]>nums[i]}\left( dp[k][1]+1 \right) \\ & dp[i][1] = \mathop{\max}_{j:nums[j]<nums[i]}\left( dp[j][0]+1 \right) \\ \text{边界条件：} & dp[1][0]=dp[1][1]=1 \\ \text{返回值：} & max(dp) \\ \text{空间压缩：} & dp[i][0] = \begin{cases} dp[i-1][0], & nums[i] \geq nums[i-1] \\ \max(dp[i-1][0], dp[i-1][1]+1) , & nums[i] < nums[i-1] \end{cases} \\ & dp[i][1] = \begin{cases} dp[i-1][1], & nums[i] \leq nums[i-1] \\ \max(dp[i-1][1], dp[i-1][0]+1) , & nums[i] > nums[i-1] \end{cases} \end{aligned} $$ |
| [646. 最长数对链](https://leetcode.cn/problems/2-keys-keyboard/) <br> **medium** | 给定一个数对数组，构造数对链：当且仅当$b < c$时，数对$p2 = [c, d]$才可以跟在$p1 = [a, b]$后面。找出能够形成的最长数对链的长度。   | $$ \begin{aligned} \text{状态定义：} & dp[i] \text{为以pairs.sort()[i]为结尾的最长数对链的长度} \\ \text{分割条件：} & pairs[j][1]<pairs[i][0] \\ \text{转移方程：} & dp[i] = \mathop{\max}_{j:pairs[j][1]<pairs[i][0]}\left( dp[j]+1 \right) \\ \text{边界条件：} & dp[i]=1 \\ \text{返回值：} & dp[n]  \end{aligned} $$ |
| [650. 只有两个键的键盘](https://leetcode.cn/problems/2-keys-keyboard/) <br> **medium** | 记事本上只有一个字符 'A' 。每次可以对记事本进行两种操作：复制全部和粘贴，返回能够打印出 n 个 'A' 的最少操作次数。  | $$ \begin{aligned} \text{状态定义：} & dp[i] \text{为能够打印出i个'A'的最少操作次数} \\ \text{分割条件：} & \text{j是i的因数} \\ \text{转移方程：} & dp[i] = \mathop{\min}_{j\%i=0}\left( dp[j]+\frac{i}{j} \right) \\ \text{边界条件：} & dp[1]=0 \\ \text{返回值：} & dp[n]  \end{aligned} $$ |



### (4) 背包问题

**背包问题 (knapsack problem)**是一种组合优化的**NP-Complete**问题：有 $N$ 个物品和容量为 $W$ 的背包，每个物品都有自己的体积 $w$ 和价值 $v$，求拿哪些物品可以使得背包所装下物品的总价值最大。

如果限定每种物品只能选择 $0$ 个或 $1$ 个，则问题称为**0-1背包**问题；如果不限定每种物品的数量，则问题称为**无界背包**问题或**完全背包**问题。

可以用动态规划来解决背包问题。把物品的迭代放在外层，里层对体积或价值进行遍历。（空间压缩后）**0-1**背包对里层的体积或价值逆向遍历；完全背包对里层的体积或价值正向遍历。

### ⚪ 0-1背包问题

对于**0-1**背包，可以定义一个二维数组 $dp$ 存储最大价值，其中 $dp[i][j]$ 表示前 $i$ 件物品体积不超过 $j$ 的情况下能达到的最大价值。

在遍历到第 $i$ 件物品时，在当前背包总容量为 $j$ 的情况下，如果我们不将物品 $i$ 放入背包，那么 $dp[i][j]= dp[i-1][j]$，即前 $i$ 个物品的最大价值等于只取前 $i-1$ 个物品时的最大价值；如果我们将物品 $i$ 放入背包，假设第 $i$ 件物品体积为 $w_i$，价值为 $v_i$，那么我们得到 $dp[i][j] = dp[i-1][j-w_i] + v_i$。只需在遍历过程中对这两种情况取最大值即可，总时间复杂度和空间复杂度都为 $O(NW)$。

$$ \begin{aligned} \text{状态定义：} & dp[i][j] \text{为前i件物品体积不超过j的情况下能达到的最大价值} \\ \text{转移方程：} & dp[i][j] = \begin{cases} \max(dp[i-1][j],dp[i-1][j-w_i]+v_i), & j \geq w_i \\ dp[i-1][j], & j < w_i  \end{cases} \\ \text{边界条件：} & dp[0][0]=0 \\ \text{返回值：} & dp[N][W] \end{aligned} $$

```python
def knapsack(weights, values, N, W):
    dp = [[0]*(W+1) for _ in range(N+1)]
    for i in range(1, N+1):
        w, v = weights[i-1], values[i-1]
        for j in range(W+1):
            if j >= w:
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-w]+v)
            else:
                dp[i][j] = dp[i-1][j]
    return dp[N][W]
```

![](https://pic.imgdb.cn/item/6420e9eea682492fccd99d3d.jpg)

我们可以进一步对**0-1**背包进行空间优化，将空间复杂度降低为 $O(W)$。如图所示，假设我们目前考虑物品 $i = 2$，且其体积为 $w = 2$，价值为 $v = 3$；对于背包容量 $j$，我们可以得到 $dp[2][j]= \max(dp[1][j], dp[1][j-2] + 3)$。这里可以发现我们永远只依赖于上一排 $i = 1$ 的信息，之前算过的其他物品($i<1$)都不需要再使用。因此我们可以去掉 $dp$ 矩阵的第一个维度，在考虑物品 $i$ 时变成 $dp[j]= \max(dp[j], dp[j-w] + v)$。

这里要注意我们在遍历每一行的时候必须**逆向遍历**，这样才能够调用上一行物品 $i-1$ 时 $dp[j-w]$ 的值；若按照从左往右的顺序进行正向遍历，则 $dp[j-w]$ 的值在遍历到 $j$ 之前就已经被更新成物品 $i$ 的值了。

```python
def knapsack(weights, values, N, W):
    dp = [0]*(W+1)
    for i in range(N):
        w, v = weights[i], values[i]
        for j in range(W, w-1, -1):
            dp[j] = max(dp[j], dp[j-w]+v)
    return dp[W]
```

| 题目 | 题干 | 解法 |
| :---:  |  :---:  |  :---:  |
| [416. 分割等和子集](https://leetcode.cn/problems/word-break/) <br> **medium** | 判断是否可以将一个只包含正整数的非空数组分割成两个元素和相等的子集。  | $$ \begin{aligned} \text{状态定义：} & dp[i][j] \text{为从数组的前i个元素中能否选出和为j的子集} \\ \text{转移方程：} & dp[i][j] = dp[i-1][j] \| dp[i-1][j-alist[i]] \\ \text{边界条件：} & dp[i][0]=True \\ \text{返回值：} & dp[len(alist)][sum(alist)/2] \\ \text{空间压缩：} & dp[j] = dp[j] \| dp[j-alist[i]] \end{aligned} $$ |
| [474. 一和零](https://leetcode.cn/problems/ones-and-zeroes/) <br> **medium** | 给定一个二进制字符串数组和两个整数m和n，返回数组的最大子集的长度，该子集中最多有m个0和n个1。  | $$ \begin{aligned} \text{状态定义：} & dp[i][j][k] \text{为从数组strs[0:i]中选出的最多有j个0和k个1的子集长度} \\ \text{转移方程：} & dp[i][j][k] = \max(dp[i-1][j][k],dp[i-1][j-strs[i].count('0')][k-strs[i].count('1')]+1) \\ \text{边界条件：} & dp[0][0][0]=0 \\ \text{返回值：} & dp[len(strs)][m][n] \\ \text{空间压缩：} & dp[j][k] = \max(dp[j][k],dp[j-strs[i].count('0')][k-strs[i].count('1')]+1) \end{aligned} $$ |
| [494. 目标和](https://leetcode.cn/problems/target-sum/) <br> **medium** | 给定一个整数数组，向数组中的每个整数前添加正或负号，求运算结果等于给定整数的不同表达式的数目。  | $$ \begin{aligned} \text{解题思路：} & \text{记sum为所有元素之和，neg为应取负号元素之和} \\  & \text{则有 (sum-neg)-neg=target，整理得 neg=(sum-target)/2} \\ & \text{问题转化为求数组中所有和为neg的元素组合} \\   \text{状态定义：} & dp[i][j] \text{为从数组nums[0:i]中选取元素之和等于j的方案数} \\ \text{转移方程：} & dp[i][j] = \begin{cases} dp[i-1][j]+dp[i-1][j-nums[i]], & j \geq nums[i] \\ dp[i-1][j], & j < nums[i] \end{cases} \\ \text{边界条件：} & dp[0][0]=1 \\ \text{返回值：} & dp[n][neg] \\ \text{空间压缩：} & dp[j] = dp[j]+dp[j-nums[i]]\end{aligned} $$ |
| [879. 盈利计划](https://leetcode.cn/problems/profitable-schemes/) <br> **hard** | 给定工作数和成员数，以及每个工作会产生的利润和需求的成员数；计算至少产生给定利润数的工作组合数量。  | $$ \begin{aligned}  \text{状态定义：} & dp[i][j][k] \text{考虑前i个任务使用不超过j名员工能获得不小于k利润的计划数} \\ \text{转移方程：} & dp[i][j][k] = \begin{cases} dp[i-1][j][k], & j < w_i \\ dp[i-1][j][k]+dp[i-1][j-w_i][\max(0,k-v_i)], & j \geq w_i \end{cases} \\ \text{边界条件：} & dp[i][j][0]=1 \\ \text{返回值：} & dp[tasks][n][minValue] \\ \text{空间压缩：} & dp[j][k] = dp[j][k]+dp[j-w_i][\max(0,k-v_i)],  j = n:w_i \end{aligned} $$ |
| [1049. 最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/) <br> **medium** | 用整数数组表示n块石头的重量。每次选出两块石头组合成重量为两者之差的绝对值的新石头，返回最后一块石头最小的可能重量。  | $$ \begin{aligned} \text{解题思路：} & \text{最后一块石头的重量可以表示为: } \sum_{i=1}^n k_i \times stones_i,k_i \in \{-1,1\} \\  & \text{记石头的总重量为sum，ki=−1的石头的重量之和为neg，则有} \\  & \sum_{i=1}^n k_i \times stones_i = (sum-neg)-neg = sum-2\cdot neg \\  & \text{要使最后一块石头的重量尽可能地小} \\ & \text{问题转化为求在不超过sum/2的前提下尽可能大的neg} \\   \text{状态定义：} & dp[i][j] \text{表示前i个石头能否凑出重量j} \\ \text{转移方程：} & dp[i][j] = \begin{cases} dp[i-1][j]\text{ or }dp[i-1][j-stones[i]], & j \geq stones[i] \\ dp[i-1][j], & j < stones[i] \end{cases} \\ \text{边界条件：} & dp[i][0]=True \\ \text{返回值：} & sum-2\cdot \mathop{\max}_{dp[n][j]=True}j \\ \text{空间压缩：} & dp[j] = dp[j]\text{ or }dp[j-stones[i]],j=sum/2:stones[i] \end{aligned} $$ |




### ⚪ 完全背包问题

在完全背包问题中，一个物品可以拿多次。如图所示，假设我们遍历到物品 $i = 2$，且其体积为 $w = 2$，价值为 $v = 3$；对于背包容量 $j = 5$，最多只能装下 $2$ 个该物品。那么我们的状态转移方程就变成了 $dp[2][5] = max(dp[1][5], dp[1][3] + 3, dp[1][1] + 6)$。如果采用这种方法，假设背包容量无穷大而物体的体积无穷小，则比较次数也会趋近于无穷大，远超 $O(NW)$ 的时间复杂度。

![](https://pic.imgdb.cn/item/6420f0c4a682492fcce17692.jpg)

怎么解决这个问题呢？我们发现在 $dp[2][3]$ 的时候其实已经考虑了 $dp[1][3]$ 和 $dp[2][1]$ 的情况，而在 $dp[2][1]$ 时也已经考虑了 $dp[1][1]$ 的情况。因此，如图所示，对于拿多个物品的情况，我们只需考虑 $dp[2][3]$ 即可，即 $dp[2][5] = max(dp[1][5], dp[2][3] + 3)$。

![](https://pic.imgdb.cn/item/6420f0dba682492fcce19119.jpg)

这样，我们就得到了完全背包问题的状态转移方程：$dp[i][j] = \max(dp[i-1][j], dp[i][j-w_i] + v_i)$，其与 **0-1** 背包问题的差别仅仅是把状态转移方程中的第二个 $i-1$ 变成了 $i$。

$$ \begin{aligned} \text{状态定义：} & dp[i][j] \text{为前i件物品体积不超过j的情况下能达到的最大价值} \\ \text{转移方程：} & dp[i][j] = \begin{cases} \max(dp[i-1][j],dp[i][j-w_i]+v_i), & j \geq w_i \\ dp[i-1][j], & j < w_i  \end{cases} \\ \text{边界条件：} & dp[0][0]=0 \\ \text{返回值：} & dp[N][W] \end{aligned} $$

```python
def knapsack(weights, values, N, W):
    dp = [[0]*(W+1) for _ in range(N+1)]
    for i in range(1, N+1):
        w, v = weights[i-1], values[i-1]
        for j in range(W+1):
            if j >= w:
                dp[i][j] = max(dp[i-1][j], dp[i][j-w]+v)
            else:
                dp[i][j] = dp[i-1][j]
    return dp[N][W]
```

同样的，我们也可以利用空间压缩将空间复杂度降低为 $O(W)$，去掉 $dp$ 矩阵的第一个维度，在考虑物品 $i$ 时变成 $dp[j]= \max(dp[j], dp[j-w] + v)$。这里要注意在遍历每一行的时候必须**正向遍历**，因为我们需要利用当前物品 $i$ 在第 $j-w$ 列的信息。

```python
def knapsack(weights, values, N, W):
    dp = [0]*(W+1)
    for i in range(N):
        w, v = weights[i], values[i]
        for j in range(w, W+1):
            dp[j] = max(dp[j], dp[j-w]+v)
    return dp[W]
```

| 题目 | 题干 | 解法 |
| :---:  |  :---:  |  :---:  |
| [322. 零钱兑换](https://leetcode.cn/problems/coin-change/) <br> **medium** | 给定一个整数数组表示不同面额的硬币，每种硬币的数量是无限的；以及一个整数表示总金额。计算可以凑成总金额所需的最少的硬币个数。  | $$ \begin{aligned} \text{状态定义：} & dp[i][j] \text{为重复使用前i个硬币凑成总金额j的最少硬币个数} \\ \text{转移方程：} & dp[i][j] = \min(dp[i-1][j],dp[i][j-coins[i]]+1) \\ \text{边界条件：} & dp[0][0]=0,dp[0][1:]=amount+2 \\ \text{返回值：} & \begin{cases} dp[m][n], & dp[m][n]<amount+2 \\ -1, & \text{otherwise}  \end{cases} \\ \text{空间压缩：} & dp[j] = \min(dp[j],dp[j-coins[i]]+1) \end{aligned} $$ |
| [518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-ii/) <br> **medium** | 给定一个整数数组表示不同面额的硬币，每种硬币的数量是无限的；以及一个整数表示总金额。计算可以凑成总金额的硬币组合数。  | $$ \begin{aligned} \text{状态定义：} & dp[i][j] \text{为重复使用前i个硬币凑成总金额j的组合数} \\ \text{转移方程：} & dp[i][j] = \begin{cases} dp[i-1][j]+dp[i][j-coins[i]], & j\geq coins[i] \\ dp[i-1][j], & j<coins[i]  \end{cases} \\ \text{边界条件：} & dp[i][0]=1 \\ \text{返回值：} &  dp[m][n] \\ \text{空间压缩：} & dp[j] = dp[j]+dp[j-coins[i]],j=coins[i]:n\end{aligned} $$ |
| [1449. 数位成本和为目标值的最大数字](https://leetcode.cn/form-largest-integer-with-digits-that-add-up-to-target/) <br> **medium** | 给定使用数位'1'-'9'的成本和一个目标数，返回总成本恰好为目标对应的最大整数。  | $$ \begin{aligned} \text{状态定义：} & dp[i][j] \text{为重复使用前i个数位凑成总成本j的最大数字} \\ \text{转移方程：} & dp[i][j] = \begin{cases} str\_max(dp[i-1][j], dp[i][j-coins[i]].max\_insert(i)), & j\geq cost[i] \\ dp[i-1][j], & j<cost[i]  \end{cases} \\ \text{边界条件：} & dp[i][0]='0' \\ \text{返回值：} &  dp[m][n] \\ \text{空间压缩：} & dp[j] = str\_max(dp[j], dp[j-coins[i]].max\_insert(i)) \end{aligned} $$ |



### (5) 股票问题

股票交易类问题通常可以用动态规划来解决。对于稍微复杂一些的股票交易类问题，比如需要冷却时间或者交易费用，则可以用通过动态规划实现的**状态机**来解决。

状态机的思想在于列举出所有可能的「状态」，然后穷举更新这些「状态」。具体到每一天，看看总共有几种可能的「状态」，再找出每个「状态」对应的「选择」。我们要穷举所有「状态」，穷举的目的是根据对应的「选择」更新状态。

```python
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 择优(选择1，选择2...)
```

股票类型的通用题目形式为给定一支股票每天的价格$prices$，并限制最大交易次数为$K$，计算能够获得的最大利润。这个问题的「状态」有三个，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（**rest**，用 1 表示持有，0 表示没有持有）。每天都有三种「选择」：买入（**buy**）、卖出（**sell**）、无操作（**rest**）。可以用三维数组存储该问题的三种状态：

```python
dp[i][k][0 or 1]
0 <= i <= n, 0 <= k <= K

for 1 <= i <= n:
    for 1 <= k <= K:
        for s in {0, 1}:
            dp[i][k][s] = max(buy, sell, rest)
```

股票问题的最终答案是$dp[n][K][0]$，即最后一天，最多允许 $K$ 次交易，最多获得多少利润。注意答案不应是$dp[n][K][1]$，因为最后手上还持有股票得到的利润一定小于手上的股票卖出得到的利润。

根据「状态」的定义可以画出状态转移图，对应一个有限状态机：

![](https://pic.imgdb.cn/item/64239d93a682492fccdd0b6a.jpg)

并进一步写出状态转移方程：

```python
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i-1])

解释：今天我没有持有股票，有两种可能：
要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；
要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。

dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i-1])

解释：今天我持有着股票，有两种可能：
要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；
要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。
```

还需要定义状态机的初始条件：

```python
dp[0][k][0] = 0
解释：因为 i 是从 1 开始的，所以 i = 0 意味着还没有开始，这时候的利润当然是 0 。
dp[0][k][1] = -infinity
解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。
dp[i][0][0] = 0
解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。
dp[i][0][1] = -infinity
解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。
```

| 题目 | 题干 | 状态机 |
| :---:  |  :---:  |  :---:  |
| [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/) <br> **easy** | 给定一支股票每天的价格，只能买卖一次，计算所能获取的最大利润。  | $$ \begin{aligned} & \text{初始状态：} \\ & \quad dp[0][0] = 0, \quad dp[0][1] = -1e9 \\ & \text{转移方程：} \\ & \quad dp[i][0] = \max(dp[i-1][0], dp[i-1][1]+prices[i-1]) \\ & \quad dp[i][1] = \max(dp[i-1][1], -prices[i-1]) \\ & \text{空间压缩：} \\ & \quad dp[0] = \max(dp[0], dp[1]+prices[i-1]) \\ & \quad dp[1] = \max(dp[1], -prices[i-1])  \end{aligned} $$ |
| [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/) <br> **medium** | 给定一支股票每天的价格，不限制购买次数，计算所能获取的最大利润。  | $$ \begin{aligned} & \text{初始状态：} \\ & \quad dp[0][0] =  0, \quad dp[0][1] = -1e9 \\ & \text{转移方程：} \\ & \quad dp[i][0] = \max(dp[i-1][0], dp[i-1][1]+prices[i-1]) \\ & \quad dp[i][1] = \max(dp[i-1][1], dp[i-1][0]-prices[i-1]) \\ & \text{空间压缩：} \\ & \quad s0 = \max(dp[0], dp[1]+prices[i-1]) \\ & \quad s1 = \max(dp[1], dp[0]-prices[i-1]) \\ & \quad dp = [s0, s1] \end{aligned} $$ |
| [123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/) <br> **hard** | 给定一支股票每天的价格，最多可以完成两笔交易，计算所能获取的最大利润。  | $$ \begin{aligned} & \text{初始状态：} \\ & \quad dp[0][k][0] = dp[i][0][0] = 0 \\  & \quad dp[0][k][1] = dp[i][0][1] = -1e9 \\ & \text{转移方程：} \\ & \quad dp[i][k][0] = \max(dp[i-1][k][0], dp[i-1][k][1]+prices[i-1]) \\ & \quad dp[i][k][1] = \max(dp[i-1][k][1], dp[i-1][k-1][0]-prices[i-1]) \\ & \text{空间压缩：} \\ & \quad dp[k][0] = \max(dp[k][0], dp[k][1]+prices[i-1]) \\ & \quad dp[k][1] = \max(dp[k][1], dp[k-1][0]-prices[i-1])\\ & \quad \text{(由于计算dp[k]用到之前的dp[k-1]，因此要倒序遍历k=2,1)} \end{aligned} $$ |
| [188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/) <br> **hard** | 给定一支股票每天的价格，最多可以完成k笔交易，计算所能获取的最大利润。  | $$ \begin{aligned} & \text{初始状态：} \\ & \quad dp[0][k][0] = dp[i][0][0] = 0 \\  & \quad dp[0][k][1] = dp[i][0][1] = -1e9 \\ & \text{转移方程：} \\ & \quad dp[i][k][0] = \max(dp[i-1][k][0], dp[i-1][k][1]+prices[i-1]) \\ & \quad dp[i][k][1] = \max(dp[i-1][k][1], dp[i-1][k-1][0]-prices[i-1]) \\ & \text{空间压缩：} \\ & \quad dp[k][0] = \max(dp[k][0], dp[k][1]+prices[i-1]) \\ & \quad dp[k][1] = \max(dp[k][1], dp[k-1][0]-prices[i-1]) \\ & \quad \text{(由于计算dp[k]用到之前的dp[k-1]，因此要倒序遍历k)} \end{aligned} $$ |
| [309. 最佳买卖股票时机含冷冻期](https://leetcode.cn/best-time-to-buy-and-sell-stock-with-cooldown/) <br> **medium** | 给定一支股票每天的价格，不限制购买次数，计算所能获取的最大利润。卖出股票后无法在第二天买入股票 (即冷冻期为 1 天)。  | $$ \begin{aligned} & \text{状态定义：}\\  &  \quad 0: \text{未持股,无冷冻} \quad 1: \text{未持股,冷冻} \quad 2: \text{持股} \\  & \text{初始状态：} \\ & \quad dp[0][0] =  0, \quad dp[0][1] = -1e9, \quad dp[0][2] = -1e9 \\ & \text{转移方程：} \\ & \quad dp[i][0] = \max(dp[i-1][0], dp[i-1][1]) \\ & \quad dp[i][1] = dp[i-1][2]+prices[i-1] \\ & \quad dp[i][2] = \max(dp[i-1][2], dp[i-1][0]-prices[i-1]) \\  & \text{返回值：} \\ & \quad \max(dp[n][0], dp[n][1]) \\ & \text{空间压缩：} \\ & \quad dp[i][0] = \max(dp[i-1][0], dp[i-1][1]+prices[i-1]) \\ & \quad dp[i][1] = \max(dp[i-1][1], dp[i-2][0]-prices[i-1]) \end{aligned} $$ |
| [714. 买卖股票的最佳时机含手续费](https://leetcode.cn/best-time-to-buy-and-sell-stock-with-transaction-fee/) <br> **medium** | 给定一支股票每天的价格，不限制购买次数，计算所能获取的最大利润。每笔交易都需要付手续费。  | $$ \begin{aligned} & \text{初始状态：} \\ & \quad dp[0][0] =  0, \quad dp[0][1] = -1e9 \\ & \text{转移方程：} \\ & \quad dp[i][0] = \max(dp[i-1][0], dp[i-1][1]+prices[i-1]-fee) \\ & \quad dp[i][1] = \max(dp[i-1][1], dp[i-1][0]-prices[i-1]) \\ & \text{空间压缩：} \\ & \quad s0 = \max(dp[0], dp[1]+prices[i-1]-fee) \\ & \quad s1 = \max(dp[1], dp[0]-prices[i-1]) \\ & \quad dp = [s0, s1] \end{aligned} $$ |




## ⚪ 分治法

**分治**问题由“分”（**divide**）和“治”（**conquer**）两部分组成，通过把原问题分为子问题，再将子问题进行处理合并，从而实现对原问题的求解。

可以使用数学表达式来表示分治过程。定义 $T(n)$ 表示处理一个长度为 $n$ 的数组的时间复杂度，则分治法的时间复杂度递推公式为 $T(n) = 2T(n/2) + O(n)$。其中 $2T(n/2)$ 表示我们分成了两个长度减半的子问题，$O(n)$ 则为合并两个长度为 $n/2$ 数组的时间复杂度。

可以利用**主定理（Master theorem）**求解最终的时间复杂度：考虑$T(n) = aT(n/b) + f(n)$，定义 $k=\log_b a$：
1. 如果 $f(n)=O(n^p)$ 且 $p<k$，那么 $T(n)=O(n^k)$；
2. 如果存在 $c\geq 0$ 满足 $f(n)=O(n^k \log^c n)$，那么 $T(n)=O(n^k \log^{c+1} n)$；
3. 如果 $f(n)=O(n^p)$ 且 $p>k$，那么 $T(n)=O(f(n))$。

分治问题可以通过主定理求得时间复杂度。如上文定义的递推公式的时间复杂度为$O(n \log n)$。

以归并排序算法为例，分治法的一般写法如下：
```python
def divide(alist):
    if len(alist) <= 1:
        return alist
    num = len(alist)//2
    left = divide(alist[0:num])
    right = divide(alist[num:])
    return conquer(left, right)
	
def conquer(left, right):
    result = []
    l, r = 0, 0
    while l<len(left) and r<len(right):
        if left[l] <= right[r]:
            result.append(left[l])
            l += 1
        else:
            result.append(right[r])
            r += 1
    result += left[l:]  # 切片超界会返回空列表
    result += right[r:]
    return result
```

| 题目 | 题干 | 解法 |
| :---:  |  :---:  |  :---:  |
| [23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/) <br> **hard** | 给定一个链表数组，每个链表都已经按升序排列，将所有链表合并到一个升序链表中。 | $$ \begin{aligned} \text{分：} & \text{将k个链表分成两组} \\ \text{治：} & \text{合并两个链表} \end{aligned} $$ |
| [241. 为运算表达式设计优先级](https://leetcode.cn/problems/different-ways-to-add-parentheses/) <br> **medium** | 给一个由数字和运算符组成的字符串，按不同优先级组合数字和运算符，计算并返回所有可能组合的结果。 | $$ \begin{aligned} \text{分：} & \text{按字符+,-,*拆分字符串} \\ \text{治：} & \text{按字符+,-,*合并结果} \end{aligned} $$ |
| [932. 漂亮数组](https://leetcode.cn/problems/beautiful-array/) <br> **medium** | 构造由范围 **[1, n]** 的整数组成的一个排列，对于每个 **0 <= i < j < n** ，均不存在下标 **k（i < k < j）**使得 **2 · nums[k] == nums[i] + nums[j]**。 | $$ \begin{aligned} \text{思路：} & 2 * nums[k] != nums[i] + nums[j] \text{ 左端为偶数}  \\ & \text{不妨取右端为奇数：i<k为奇数，j>k为偶数} \\ & \text{注意到线性变换a*nums+b不改变不等式关系} \\  \text{分：} & \text{构造从1到(N + 1)/2的所有整数的漂亮数组} \\ & \text{构造从1到N的所有整数的漂亮数组} \\ \text{治：} & \text{把从1到(N + 1)/2的漂亮数组映射成$1$到$N$范围的所有奇数} \\ & \text{把从1到N/2的漂亮数组映射成$1$到$N$范围的所有偶数} \end{aligned} $$ |


## ⚪ 位运算

位运算是算法题里比较特殊的一种类型，它们利用二进制位运算的特性进行一些奇妙的优化和计算。

**Python**实现整型与二进制之间的转换：

```python
# 整型 -> 二进制
b = bin(n) # 返回一个整数n的以'0b'开始的二进制表示形式的字符串。
b = '{0:b}'.format(n) # 返回一个整数n的二进制表示形式的字符串。

# 二进制 -> 整型
n = int(b, 2) # 把二进制字符串转换为整型
```


常用的位运算符号包括：

```python
"""
& 按位与    | 按位或   ^ 按位异或 ~ 按位取反
<< 按位左移：相当于乘以2，运算优先级较低
>> 按位右移：相当于整除2，运算优先级较低
"""
```

以下是一些常见的位运算特性，其中 **0s** 和 **1s** 分别表示只由 **0** 或 **1** 构成的二进制数字。

```python
x ^ 0s = x    x & 0s = 0    x | 0s = x
x ^ 1s = ~x   x & 1s = x    x | 1s = 1s
x ^ x = 0     x & x = x     x | x = x
```

下面是一些位运算的技巧：
- `n & 1`：可以取出 **n** 的最后一位。
- `n & (n+1)`：可以判断 **n** 的二进制表示是否全为 **1**。
- `n & (n-1)`：可以去除 **n** 的位级表示中为**1**的最低的那一位，例如对于二进制表示 **11110100**，减去 **1** 得到 **11110011**，这两个数按位与得到 **11110000**。
- `n & (-n)`：可以得到 **n** 的位级表示中**1**的最低
的那一位，例如对于二进制表示 **11110100**，取负得到 **00001100**（负数以补码的形式表示，最高位即符号位，剩下的位按位取反，末位加**1**），这两个数按位与得到 **00000100**。

| 题目 | 题干 | 解法 |
| :---:  |  :---:  |  :---:  |
| [136. 只出现一次的数字](https://leetcode.cn/problems/single-number/) <br> **easy** | 给定一个整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 | 将数组内所有的数字进行按位异或。出现两次的所有数字按位异或的结果是 0，0 与出现一次的数字异或可以得到这个数字本身。 <br> `n^n=0, n^0=n` |
| [137. 只出现一次的数字 II](https://leetcode.cn/problems/single-number-ii/) <br> **medium** | 给定一个整数数组，除某个元素仅出现一次外，其余每个元素都恰出现三次。找出那个只出现了一次的元素。 | 答案的第i个二进制位就是数组中所有元素的第i个二进制位之和除以3的余数。注意第31个二进制位（即最高位）是补码意义下的符号位，若为1则应进行操作`ans-=(1<<31)`。 |
| [190. 颠倒二进制位](https://leetcode.cn/problems/reverse-bits/) <br> **easy** | 颠倒给定的 32 位无符号整数的二进制位。 | 使用算术左移和右移，可以很轻易地实现二进制的翻转。 <br> `ans<<=1, ans+=n&1, n>>=1` |
| [231. 2 的幂](https://leetcode.cn/problems/power-of-two/) <br> **easy** | 给定一个整数 n，判断该整数是否是 2 的幂次方。 | 如果一个数字n是2的整数次方，那么它的二进制一定是10...0的形式；考虑到n−1的二进制是01...1，这两个数求按位与的结果一定是0。 <br> `n>0 and n&(n-1)==0` |
| [260. 只出现一次的数字 III](https://leetcode.cn/problems/single-number-iii/) <br> **medium** | 给定一个整数数组 ，其中恰好有两个元素只出现一次，其余所有元素均出现两次。找出只出现一次的那两个元素。 | 将数组内所有的数字进行按位异或得到这两个数按位异或的结果，使用位运算`x&(-x)`取出其二进制表示中最低位那个 1，并按照这一位是否为1把所有元素分成两类，对于任意一个在数组中只出现了一次的元素，即，它们会被包含在不同类中。 |
| [268. 丢失的数字](https://leetcode.cn/problems/missing-number/) <br> **easy** | 给定一个包含 [0, n] 中 n 个数的数组，找出 [0, n] 这个范围内没有出现在数组中的那个数。 | 在数组后面添加从 0 到 n 的每个整数，把问题转换成“136. 只出现一次的数字”。 |
| [318. 最大单词长度乘积](https://leetcode.cn/problems/maximum-product-of-word-lengths/) <br> **medium** | 给定一个字符串数组 ，找出数组中两个单词长度乘积的最大值，并且这两个单词不含有公共字母。 | 遍历字符串数组中的每一对单词，通过位运算操作判断两个单词是否有公共字母。 |
| [326. 3 的幂](https://leetcode.cn/problems/power-of-three/) <br> **easy** | 给定一个整数，判断它是否是 3 的幂次方。 | 一个数乘以3相当于一个数左移（乘以2）再加这个数。<br> `n*3 == (n<<1) + n` |
| [338. 比特位计数](https://leetcode.cn/problems/counting-bits/) <br> **easy** | 给定一个整数 n，计算其二进制表示中 1 的个数。 | $$ \begin{aligned} \text{状态定义：} & dp[i] \text{表示数字 i 的二进制含有 1 的个数} \\ \text{转移方程：} & dp[i] = \begin{cases} dp[i-1]+1,& \text{i 的最后一位为1} \\ dp[i>>1],& \text{i 的最后一位为0} \end{cases} \\ \text{边界条件：} & dp[0]=0 \\ \text{返回值：} & dp  \end{aligned} $$ |
| [342. 4的幂](https://leetcode.cn/problems/power-of-four/) <br> **easy** | 给定一个整数 n，判断该整数是否是 4 的幂次方。 | 如果一个数字n是4的整数次方，那么它一定是2的整数次方，并且二进制表示中 1 的位置必须为奇数位；把 n 和二进制的 10101...101（即十进制下的 1431655765）做按位与。 <br> `n>0 and n&(-n)==n and n&int('10'*15+'1',2)!=0` |
| [461. 汉明距离](https://leetcode.cn/problems/hamming-distance/) <br> **easy** | 计算两个整数之间的汉明距离，两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。 | 对两个数进行按位异或操作，统计有多少个 1 即可。 <br> `bin(x^y).count('1')` |
| [476. 数字的补数](https://leetcode.cn/problems/number-complement/) <br> **easy** |给定一个整数，输出它的补数。对整数的二进制表示取反后，再转换为十进制表示，可以得到这个整数的补数。 | 构造全1掩码并与原数进行异或运算。 <br> `int('1'*(len(bin(num))-2), 2)^num` |
| [693. 交替位二进制数](https://leetcode.cn/problems/binary-number-with-alternating-bits/) <br> **easy** | 给定一个正整数，检查它的二进制表示是否总是 0、1 交替出现。 | 当且仅当输入 n 为交替位二进制数时，`n^(n>>1)` 的二进制表示全为 1，当且仅当 a 的二进制表示全为 1 时，`a&(a+1)`结果为 0。 |


## ⚪ 数学问题

### （1）数论

利用**辗转相除法**，我们可以很方便地求得两个数的**最大公因数（greatest common divisor，gcd）**；将两个数相乘再除以最大公因数即可得到**最小公倍数（least common multiple, lcm）**。

```python
def gcd(a, b):
    return a if b == 0 else gcd(b, a%b)

def lcm(a, b):
    return a * b / gcd(a, b)
```

| 题目 | 题干 | 解法 |
| :---:  |  :---:  |  :---:  |
| [168. Excel表列名称](https://leetcode.cn/problems/excel-sheet-column-title/) <br> **easy** | 给定一个整数，返回它在 Excel 表中相对应的列名称（A->1,Z->26,AA->27）。 | 等价于26进制转换问题。注意取值从1开始，因此执行`divmod()`前应减去1（对齐到$[0,25]$）。 |
| [169. 多数元素](https://leetcode.cn/problems/majority-element/) <br> **easy** | 给定一个数组，返回其中的多数元素。多数元素是指在数组中出现次数大于数组长度的一半的元素。 | **Boyer-Moore投票算法**：第一个到来的士兵，直接插上自己阵营的旗帜占领这块高地；如果新来的士兵和前一个士兵是同一阵营，则集合起来占领高地；如果新来到的士兵不是同一阵营，则前方阵营派一个士兵和它同归于尽；当下一个士兵到来，发现前方阵营已经没有兵力，新士兵就成了领主。 |
| [172. 阶乘后的零](https://leetcode.cn/problems/factorial-trailing-zeroes/) <br> **medium** | 给定一个整数n，返回n的阶乘结果中尾随零的数量。 | n的阶乘尾零的数量即为其中因子10的个数，由于质因子 5 的个数不会大于质因子 2 的个数，因此统计 [1,n] 的每个数的质因子 5 的个数之和。 |
| [204. 计数质数](https://leetcode.cn/problems/count-primes/) <br> **medium** | 给定整数n，返回所有小于非负整数n的质数的数量。质数指的是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。 | **埃拉托斯特尼筛法（Sieve of Eratosthenes，简称埃氏筛法）**：从 1 到 n 遍历，假设当前遍历到 m，则把所有小于 n 的、且是 m 的倍数的整数标为合数；遍历完成后，没有被标为合数的数字即为质数。 |
| [504. 七进制数](https://leetcode.cn/problems/base-7/) <br> **easy** | 给定一个整数，将其转化为 7 进制，并以字符串形式输出。 | 进制转换类型的题目，通常是利用除法和取模运算`divmod()`来进行计算。 |
| [462. 最小操作次数使数组元素相等 II](https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/) <br> **medium** | 给定一个整数数组，返回使所有数组元素相等需要的最小操作数。在一次操作中，可以使数组中的一个元素加 1 或者减 1。 | 使所有数组元素相等的取值应为数组的中位数。 |


### （2）随机采样


```python
# 从$[0, 1)$中随机采样一个浮点数数
p = random.random()

# 从$[1, n)$中随机采样一个整数
i = random.randrange(1, n, step=1)

# 随机打乱一个数组：
random.shuffle(alist)
```

| 题目 | 题干 | 解法 |
| :---:  |  :---:  |  :---:  |
| [382. 链表随机节点](https://leetcode.cn/problems/linked-list-random-node/) <br> **medium** | 给定一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点被选中的概率一样。 | **水库采样算法**：在遍历到第 $m$ 个节点时，有 $1/m$ 的概率选择这个节点覆盖掉之前的节点选择。对于长度为 $n$ 的链表的第 $m$ 个节点，最后被采样的充要条件是它被选择，且之后的节点都没有被选择。这种情况发生的概率为 $\frac{1}{m}\times\frac{m}{m+1}\times\frac{m+1}{m+2}\times \cdots \times \frac{n-1}{n}=\frac{1}{n}$。因此每个点都有均等的概率被选择。 |
| [384. 打乱数组](https://leetcode.cn/problems/shuffle-an-array/) <br> **medium** | 给定一个整数数组，设计算法来打乱一个没有重复元素的数组。 | **Fisher-Yates洗牌算法**：通过随机交换位置来实现随机打乱。按$0\leq i <n$遍历数组，对于每次循环，在 $[i,n)$ 中随机抽取一个下标 $j$，将第 $i$ 个元素与第 $j$ 个元素交换。 |
| [398. 随机数索引](https://leetcode.cn/problems/random-pick-index/) <br> **medium** | 给定一个可能含有重复元素的整数数组，随机输出给定的目标数字的索引。如果存在多个有效的索引，则每个索引的返回概率应当相等。 | 使用哈希字典存储每个数字的所有索引，然后随机采样一个索引。 |
| [470. 用 Rand7() 实现 Rand10()](https://leetcode.cn/problems/implement-rand10-using-rand7/) <br> **medium** | 给定方法 rand7 可生成 [1,7] 范围内的均匀随机整数，试写一个方法 rand10 生成 [1,10] 范围内的均匀随机整数。 | 古典概型：构造 2 次采样，分别有 2 种（如rand7 拒绝 7，相当于对 [1,6] 采样，把奇数和偶数作为 2 种结果）和 5 种结果（如rand7 拒绝 6,7，然后对 [1,5] 采样），组合起来便有 10 种概率相同的结果，把这些结果映射到 [1,10] 即可。 |
| [528. 按权重随机选择](https://leetcode.cn/problems/random-pick-with-weight/) <br> **medium** | 给定一个正整数数组，其中每个元素代表该元素下标的权重；按权重随机地选出一个下标。 | 存储数组的前缀和，每当需要采样时，先随机产生一个数字，然后使用二分法查找其在前缀和中的位置，以模拟加权采样的过程。 |



# 二、数据结构篇

数据结构可以用来实现各种算法，因此必须熟悉各种数据结构的特点。

## ⚪ 字符串

字符串是由字符组成的数组。由于字符串是程序里经常需要处理的数据类型，因此有很多针对字符串处理的题目。

有时需要进行字符的数值运算，可以通过`ord()`函数把它们转换成ASCII码后再计算：

```python
ord('z') - ord('a') # 25
```

### （1）字符串理解

字符串理解是指按要求处理给定的单个字符串。

寻找字符串中的回文子串通常采用**中心扩展**算法，枚举所有的「回文中心」（字符串的每个位置），并尝试「扩展」（向左向右延长），直到无法扩展为止（不再满足回文条件）。需要注意回文串长度有奇数和偶数两种情况，需要分开讨论。

```python
n = len(s)
for i in range(n):

   # 奇数情况
   l, r = i-1, i+1
   while l>=0 and r<n:
       if s[l] == s[r]:
           l -= 1
           r += 1
       else:
           break
   # s[l+1:r]是一个长度为r-l-1的回文子串

   # 偶数情况
   l, r = i-1, i
   while l>=0 and r<n:
       if s[l] == s[r]:
           l -= 1
           r += 1
       else:
           break
   # s[l+1:r]是一个长度为r-l-1的回文子串
```



| 题目 | 题干 | 解法 |
| :---:  |  :---:  |  :---:  |
| [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/) <br> **medium** | 给定一个字符串，找出其中不含有重复字符的最长子串的长度。| 使用滑动窗口枚举不含重复字符的子串，使用哈希集合判断是否有重复的字符。 |
| [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/) <br> **medium** | 给定一个字符串，找出其中最长的回文子串。| 计算以每个位置为回文中心的回文串的长度。 |
| [227. 基本计算器 II](https://leetcode.cn/problems/basic-calculator-ii/) <br> **medium** | 给定一个由整数和算符（加减乘除）组成的字符串表达式，实现一个基本计算器来计算并返回它的值。| 由于乘除优先于加减计算，对于加减号后的数字，将其直接压入一个栈中；对于乘除号后的数字，可以直接与栈顶元素计算，并替换栈顶元素为计算后的结果。 |
| [409. 最长回文串](https://leetcode.cn/problems/longest-palindrome/) <br> **easy** | 给定一个包含大写字母和小写字母的字符串，返回通过这些字母构造成的最长的回文串。| 将每个字符使用偶数次，如果有剩余的字符，再取出一个作为回文中心。 |
| [647. 回文子串](https://leetcode.cn/problems/palindromic-substrings/) <br> **medium** | 给定一个字符串，统计这个字符串中回文子串的数目。回文字符串是正着读和倒过来读一样的字符串。| 从字符串的每个位置开始，向左向右延长，判断存在多少以当前位置为中轴（分别考虑奇数和偶数长度）的回文子字符串。 |
| [696. 计数二进制子串](https://leetcode.cn/problems/count-binary-substrings/) <br> **easy** | 给定一个字符串，统计具有相同数量0和1的连续子字符串的数量，这些子字符串中的所有0和所有1都是成组连续的。| 将字符串按照0和1的连续段分组，遍历所有相邻的数对，对应$u$个0和$v$个1，能组成的满足条件的子串数目为$\min(u,v)$。 |


### （2）字符串比较

字符串比较是指按要求比较给定的两个或多个字符串。

| 题目 | 题干 | 解法 |
| :---:  |  :---:  |  :---:  |
| [67. 二进制求和](https://leetcode.cn/problems/add-binary/) <br> **easy** | 给定两个二进制字符串，以二进制字符串的形式返回它们的和。 | 从后往前逐位模拟二进制加法运算，考虑进位、位数差等细节。 |
| [205. 同构字符串](https://leetcode.cn/problems/isomorphic-strings/) <br> **easy** | 给定两个字符串s和t，判断它们是否是同构的。如果s中的字符可以按某种映射关系（不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身）替换得到t，那么这两个字符串是同构的。| 维护两张哈希表，第一张哈希表以s中字符为键，映射至t的字符为值；第二张哈希表以t中字符为键，映射至s的字符为值。|
| [242. 有效的字母异位词](https://leetcode.cn/problems/valid-anagram/) <br> **easy** | 给定两个字符串s和t，判断t是否是s的字母异位词。若s和t中每个字符出现的次数都相同，则称s和t互为字母异位词。| 用哈希表或者数组统计两个数组中每个数字出现的频次，若频次相同，则说明它们包含的字符完全相同。 |
| [415. 字符串相加](https://leetcode.cn/problems/add-strings/) <br> **easy** | 给定两个字符串形式的非负整数，计算它们的和并同样以字符串形式返回。 | 从后往前逐位模拟加法运算，考虑进位、位数差等细节。 |

## ⚪ 基本数据结构

### （1）数组 array

数组是最常用的数据结构之一，在**python**中体现为列表`list`。

| 题目 | 题干 | 解法 |
| :---:  |  :---:  |  :---:  |
| [48. 旋转图像](https://leetcode.cn/problems/rotate-image/) <br> **medium** | 把一个 n × n 的二维矩阵顺时针旋转 90 度，需要直接修改输入的二维矩阵。| 解法①：每一次原地交换四个位置，对应索引的赋值关系： <br> $$ \begin{aligned} &(i,j) \to (j,n-i-1) \\ &(j,n-i-1) \to (n-i-1,n-j-1) \\ &(n-i-1,n-j-1) \to (n-j-1,i) \\ &(n-j-1,i) \to (i,j) \\ & i\in [0, n//2) , j\in [0, (n+1)//2) \end{aligned} $$ <br> 解法②：水平轴翻转+主对角线翻转(转置)  <br> $$ (i,j) \to (n-i-1,j) \to (j,n-i-1) $$ |
| [240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/) <br> **medium** | 搜索二维矩阵 matrix 中的一个目标值。该矩阵每行的元素从左到右升序排列，每列的元素从上到下升序排列。 | 从右上角开始查找，若当前值大于待搜索值，向左移动一位；若当前值小于待搜索值，向下移动一位。若坐标越界则说明待搜索值不存在于矩阵中。 |
| [287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/) <br> **medium** | 给一个含 n+1 个整数的数组，其数字在 [1, n] 范围内，假设数组只有一个重复的整数，返回这个重复的数。 | 鸽笼原理：把出现的数字在原数组出现的位置设为负数。 |
| [448. 找到所有数组中消失的数字](https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/) <br> **easy** | 给一个含 n 个整数的数组，找出所有在 [1, n] 范围内但没有出现在数组中的数字。| 鸽笼原理：把重复出现的数字在原数组出现的位置设为负数，最后仍然为正数的位置即为没有出现过的数。 |
| [566. 重塑矩阵](https://leetcode.cn/problems/reshape-the-matrix/) <br> **easy** | 把一个 **m x n** 矩阵重塑为另一个大小不同（**r x c**）的新矩阵。| 对于矩阵中第$x \in [0,mn)$个元素：<br> $$ mat2[x//c,x\%c] = mat1[x//n,x\%n] $$ |
| [769. 最多能完成排序的块](https://leetcode.cn/problems/max-chunks-to-make-sorted/) <br> **medium** | 给定一个在 [0, n - 1] 范围内的整数的排列。返回数组能分成的最多块数量，使得对每个块单独排序并连接起来后，结果和按升序排序后的原数组相同。 | 从左往右遍历，同时记录当前的最大值，每当当前最大值等于数组位置时，可以多一次分割。 |


### （2）栈和队列 Stack and Queue

栈是一种**后入先出（LIFO）**的数据结构，常用于深度优先搜索、一些字符串匹配问题以及单调栈问题。队列是一种**先入先出（FIFO）**的数据结构，常用于广度优先搜索。

栈和队列在**python**中都可以用列表`list`实现；为了实现$O(1)$的头部增删和尾部增删，默认基于双端队列`collections.deque`实现。

```python
from collections import deque

stack = deque([])
stack.append()
stack.pop()

queue = deque([])
queue.append()
queue.pop(0)
```

| 题目 | 题干 | 解法 |
| :---:  |  :---:  |  :---:  |
| [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/) <br> **easy** | 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。| 从左往右遍历，每当遇到左括号便放入栈内，遇到右括号则判断其和栈顶的括号是否是统一类型，是则从栈内取出左括号，否则说明字符串不合法。 |
| [155. 最小栈](https://leetcode.cn/problems/min-stack/) <br> **medium** | 设计一个支持 **push ，pop ，top** 操作，并能在常数时间内检索到最小元素的栈。 | 额外建立一个新栈，栈顶表示原栈里所有值的最小值。 |
| [225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/) <br> **easy** | 仅使用两个队列实现后入先出栈。栈应当支持一般栈支持的所有操作（**push、pop、top、empty**）。| 使用列表模拟队列，在取值时通过一个额外队列翻转一次数组。 |
| [232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/) <br> **easy** | 仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（**push、pop、peek、empty**）。| 使用列表模拟栈，在取值时通过一个额外栈翻转一次数组。 |

### （3）单调栈

单调栈通过维持栈内值的单调递增（递减）性，在整体 $O(n)$ 的时间内处理需要大小比较的问题。

单调栈经常被用于寻找数组中当前位置对应的下一个更大/小值，此时可以维护一个存储下标的单调递减/递增栈。以寻找更大值为例，维持一个存储下标的单调递减栈，每次有下标进栈时，会将对应数值更小的下标全部出栈，并更新这些下标对应的下一个更大值；同时，栈顶元素也记录了该下标对应的上一个更大值：

```python
stack = []
for i in range(n):
   while stack and nums[stack[-1]] < nums[i]:
       idx = stack.pop()
       next_maximum[idx] = nums[i]
       prev_maximum[idx] = stack[-1]
   stack.append(i)
```

| 题目 | 题干 | 解法 |
| :---:  |  :---:  |  :---:  |
| [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/) <br> **hard** | 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。| 使用单调递减栈寻找下一个更大值和上一个更大值，并累计雨水。 |
| [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/) <br> **hard** | 给定 n 个非负整数表示柱状图中各个柱子的高度，求该柱状图中能够勾勒出来的矩形的最大面积。| 使用单调递增栈寻找下一个更小值和上一个更小值（出栈后的栈顶元素）。 |
| [496. 下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/) <br> **easy** | 给定一个数组，返回数组的一个子集中每个元素在原数组中的下一个更大元素。| 使用单调递减栈寻找下一个更大值，并将对应关系存储为哈希表。 |
| [503. 下一个更大元素 II](https://leetcode.cn/problems/next-greater-element-ii/) <br> **medium** | 给定一个循环数组，返回数组中每个元素的下一个更大元素。| 使用单调递减栈寻找下一个更大值；对于第一次遍历没有找到对应更大值的下标，再进行第二次遍历，此时只出栈。 |
| [739. 每日温度](https://leetcode.cn/problems/daily-temperatures/) <br> **medium** | 给定一个整数数组表示每天的温度，返回一个数组，其中第i个元素是指对于第i天，下一个更高温度出现在几天后。| 使用单调递减栈寻找下一个更大值，并更新出栈下标对应的等待天数。 |

### （4）优先队列（堆）

优先队列 (**priority queue**) 是一种最大值（或最小值）先出的数据结构。它可以在$O(n \log n)$的时间排序数组，$O(1)$的时间获得最大值，$O(\log n)$的时间插入任意值或删除最大值。优先队列常用于维护数据结构并快速获取最大或最小值。

优先队列是通过堆（**queue**）这种数据结构实现的。**python**中的`heapq`库提供了优先队列的基本操作，相当于最小堆：

```python
import heapq
queue = []

# 注意 Python 默认的优先队列是最小堆
heapq.heappush(queue, elem) # 添加元素
heapq.heappop(queue) # 弹出最小元素

queue.remove(elem) # 删除任意元素
heapq.heapify(queue) # 删除后要恢复堆的性质
```

| 题目 | 题干 | 解法 |
| :---:  |  :---:  |  :---:  |
| [23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/) <br> **hard** | 给定一个链表数组，每个链表都已经按升序排列，将所有链表合并到一个升序链表中。 |使用优先队列维护当前每个链表没有被合并的元素的最前面一个，每次在这些元素里面选取最小的元素合并到答案中。 |
| [218. 天际线问题](https://leetcode.cn/problems/the-skyline-problem/) <br> **hard** | 城市的天际线是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给出所有建筑物的位置和高度，请返回由这些建筑物形成的天际线。 |存储建筑物的端点和高度，依次按照端点大小、左端点、较大高度排序。然后依次读取端点和高度：如果是左端点，说明存在一条往右延伸的可记录的边，将高度存入优先队列；如果是右端点，说明这条边结束了，将当前高度从队列中移除。取出最高高度，如果当前不与前一矩形“上边”延展而来的那些边重合，则可以被记录。 |
| [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/) <br> **hard** | 给定一个整数数组，有一个滑动窗口从数组的最左侧移动到数组的最右侧，记录滑动窗口在每个位置的最大值。 | 每次向右移动窗口时，把新的元素及其索引放入优先队列中。然后不断地移除堆顶不在窗口范围内的元素，直到其确实出现在滑动窗口中。 |
| [264. 丑数 II](https://leetcode.cn/problems/ugly-number-ii/) <br> **medium** | 给定一个整数n，找出第n个丑数，丑数是只包含质因数 2、3 和/或 5 的正整数。 | 维护一个最小堆，每次取出堆顶元素$x$，则$2x,3x,5x$也是丑数；为了避免重复元素，使用哈希集合去重。 |



### （5）哈希表（字典和集合）

**哈希表 (hash)**又称散列表，使用 $O(n)$ 空间复杂度存储数据，通过哈希函数映射位置，从而实现近似 $O(1)$ 时间复杂度的插入、查找、删除等操作。

**python**提供了字典`dict`和集合`set`数据结构作为哈希表，可以用来统计频率，记录内容等等。有时需要为不存在的键设置默认值，也可以用`collections.defaultdict`实现。

```python
from collections import defaultdict
dd = defaultdict(lambda: 0)
```


| 题目 | 题干 | 解法 |
| :---:  |  :---:  |  :---:  |
| [1. 两数之和](https://leetcode.cn/problems/two-sum/) <br> **easy** | 给定一个整数数组和一个整数目标值，在数组中找出和为目标值的两个整数。 | 用字典存储遍历过的值以及它们的位置，每次遍历到新的位置时，查找字典里是否存在满足求和条件的值。 |
| [128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/) <br> **medium** | 给定一个未排序的整数数组，找出数字连续的最长序列的长度。 | 用字典存储数组中的值，搜索每个连续序列的起点，并记录它们的最大连续长度。 |
| [149. 直线上最多的点数](https://leetcode.cn/problems/max-points-on-a-line/) <br> **hard** | 给定一个数组，其中每个元素表示 **X-Y** 平面上的一个点。求最多有多少个点在同一条直线上。 | 对于每个点，对其它点建立字典，统计同一斜率的点一共有多少个，要考虑斜率不存在和重复坐标的情况。 |
| [217. 存在重复元素](https://leetcode.cn/problems/contains-duplicate/) <br> **easy** | 给定一个整数数组，判断是否存在任一值在数组中出现至少两次。 | 使用集合去重。 |
| [594. 最长和谐子序列](https://leetcode.cn/problems/longest-harmonious-subsequence/) <br> **easy** | 和谐数组是指一个数组里元素的最大值和最小值之间的差别正好是 1 。给定一个整数数组，在所有可能的子序列中找到最长的和谐子序列的长度。 | 使用字典存储每个数出现的频数。 |
| [697. 数组的度](https://leetcode.cn/problems/degree-of-an-array/) <br> **easy** | 给定一个非空且只包含非负数的整数数组，数组的度的定义是指数组里任一元素出现频数的最大值。在数组中找到与数组拥有相同大小的度的最短连续子数组，返回其长度。 | 使用字典存储每个数出现的频数、首次出现位置和最后出现位置。 |






## ⚪ 基于指针的数据结构

### （1）链表

**（单）链表**是由节点和指针构成的数据结构，每个节点存有一个值，和一个指向下一个节点的指针。

不同于数组，链表并不能直接获取任意节点的值，必须要通过指针找到该节点后才能获取其值。同理，在未遍历到链表结尾时，我们也无法知道链表的长度，除非依赖其他数据结构储存长度。**LeetCode** 默认的链表表示方法如下。

```python
# Definition for singly-linked list.
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
```

由于在进行链表操作时，尤其是删除节点时，经常会因为对当前节点进行操作而导致内存或指针出现问题。有两个小技巧可以解决这个问题：一是尽量处理当前节点的下一个节点而非当前节点本身，二是建立一个**哑节点 (dummy node)**，使其指向当前链表的头节点，这样即使原链表所有节点全被删除，也会有一个 **dummy** 存在，返回 **dummy.next** 即可。

建立哑节点：

```python
dummy = ListNode(0)
dummy.next = head
# 处理链表
return dummy.next
```

很多链表问题可以用**递归**来处理，比如递归提供了一种优雅的方式来反向遍历节点。

```python
def reverse_node(head):
    if not head:
        return
    reverse_node(head.next)
    return head.val
```

值得一提的是，在许多语言中，递归堆栈帧的开销很大（如 **Python**），并且最大的运行时堆栈深度为 $1000$（可以增加，但是有可能导致底层解释程序内存出错）。为每个节点创建堆栈帧极大的限制了算法能够处理的最大链表大小。


| 题目 | 题干 | 解法 |
| :---:  |  :---:  |  :---:  |
| [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/) <br> **medium** | 给定一个链表，删除链表的倒数第n个结点。 | 先后指针：使用两个指针 first 和 second 同时对链表进行遍历，并且 first 比 second 超前 n 个节点。当 first 遍历到链表的末尾时，second 就恰好处于倒数第 n 个节点。 |
| [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/) <br> **easy** | 将两个升序链表合并为一个新的升序链表并返回。 | 解法①：迭代，使用一个哨兵节点存储当前较小的节点 <br> 解法②：递归，问题拆分成当前较小节点+合并下一个节点指向的链表和另一个链表，终止条件为至少有一个链表为空 |
| [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/) <br> **medium** | 给定一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。 | 解法①：迭代，使用两个指针分别存储前一个和后一个节点 <br> $$ \begin{aligned} pre &= dummy \\ pre.next &= head.next \\ next &= head.next.next \\ head.next.next &= head \\ pre &= head \\ head.next & = next \\ head &= head.next \end{aligned} $$ <br> 解法②：递归，问题拆分成前两个节点+第三个节点指向的链表，终止条件为空或者单节点 |
| [83. 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/) <br> **easy** | 给定一个已排序的链表的头节点，删除所有重复的元素，使每个元素只出现一次。 | 比较当前节点和下一个节点的数值：若相等则跳过下一个节点，否则指向下一个节点。 |
| [148. 排序链表](https://leetcode.cn/problems/sort-list/) <br> **medium** | 给定链表的头节点，将其按升序排列并返回排序后的链表。 | 利用快慢指针找到链表中点后，可以对链表进行归并排序。 |
| [160. 相交链表](https://leetcode.cn/problems/reverse-linked-list/) <br> **easy** | 给定两个单链表的头节点，找出两个单链表相交的起始节点。 | 双指针：创建两个指针初始时分别指向两个链表的头节点，然后将两个指针依次遍历两个链表的每个节点，如果指针为空则指向另一个链表的头节点，最后两个指针会指向同一个节点或者都为空。 |
| [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/) <br> **easy** | 给定单链表的头节点，反转链表并返回。 | 解法①：迭代，使用两个指针分别存储前一个和后一个节点 <br> $$ \begin{aligned} pre &= None \\ next &= head.next \\ head.next &= pre \\ pre &= head \\ head &= next \end{aligned} $$ <br> 解法②：递归，问题拆分成第一个节点+第二个节点指向的链表，终止条件为空或者单节点 |
| [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/) <br> **easy** | 给定一个单链表的头节点，判断该链表是否为回文链表。 | 解法①：先使用快慢指针找到链表中点，再把链表切成两半；然后把后半段翻转；最后比较两半是否相等。 <br> 解法②：递归，使用递归反向迭代节点，同时使用递归函数外的变量向前迭代，匹配两者的数值。 |
| [328. 奇偶链表](https://leetcode.cn/problems/odd-even-linked-list/) <br> **medium** | 给定单链表的头节点，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。 | 将奇数节点和偶数节点分离成奇数链表和偶数链表，然后将偶数链表连接在奇数链表之后，合并后的链表即为结果链表。 |


### （2）树

**树**是单链表的升级版，如无特别说明，本文主要讨论**二叉树（binary tree）**，即每个节点最多有两个子节点；其与链表的主要差别就是多了一个子节点的指针。**LeetCode** 默认的树表示方法如下。

```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
```

### ⚪ 树的递归

树的递归是指首先处理以当前节点为根节点的树，再递归地处理左右子树；其写法与深度优先搜索的递归写法相同。


| 题目 | 题干 | 解法 |
| :---:  |  :---:  |  :---:  |
| [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/) <br> **easy** | 给定一个二叉树的根节点，检查它是否轴对称。 | 递归：判断一个树是否对称等价于判断左右子树是否对称。（1）如果两个子树都为空指针，则它们相等或对称；（2）如果两个子树只有一个为空指针，则它们不相等或不对称；（3）如果两个子树根节点的值不相等，则它们不相等或不对称（4）根据相等或对称要求，进行递归处理。 |
| [110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/) <br> **easy** | 给定一个二叉树，判断它是否是高度平衡的二叉树。一棵高度平衡二叉树定义为：一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。 | 解法①：自顶向下的递归（前序遍历），先判断以当前节点为根结点的二叉树是否平衡，再判断左子树和右子树是否平衡。 <br> 解法②：自底向上的递归（后序遍历），先递归地判断其左右子树是否平衡，再判断以当前节点为根的子树是否平衡。 |
| [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/) <br> **easy** | 给定一个二叉树的根节点，翻转这棵二叉树，并返回其根节点。 | 递归地翻转左右子树，再交换两棵子树的位置。 |
| [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/) <br> **medium** | 给定一个二叉树，找到该树中两个指定节点的最近公共祖先。 | 最近公共祖先应满足：左右子树分别包含一个指定节点或根结点为其中一个节点。递归地判断左右子树是否包含指定节点。 |
| [437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/) <br> **medium** | 给定一个二叉树的根节点和一个整数，求该二叉树里节点值之和等于该整数的路径的数目。 | 解法①：前序遍历，先计算从当前节点出发的路径中满足条件的数量，再计算从左子树和右子树出发的路径树。<br> 解法②：使用前缀和哈希记录由根结点到当前结点的路径上所有节点的和；对于当前节点，路径数目为当前节点值减去目标值对应的哈希值；退出当前节点时需要移除当前前缀和。 |
| [543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/) <br> **easy** | 给定一个二叉树，计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。 | 递归地计算左右子节点的最大深度。 |
| [572. 另一棵树的子树](https://leetcode.cn/problems/subtree-of-another-tree/) <br> **easy** | 给定两棵二叉树 root 和 subRoot，检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。 | 判断当前节点是否指向subRoot，然后递归地检查左右子节点。 |
| [617. 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/) <br> **easy** | 给定两棵二叉树，将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则不为 null 的节点将直接作为新二叉树的节点。 | 合并当前节点，然后递归地合并左右子树。 |
| [1110. 删点成林](https://leetcode.cn/problems/delete-nodes-and-return-forest/) <br> **medium** | 给定一个二叉树的根节点，树上每个节点都有一个不同的值，如果节点值在待删除数组中出现，就把该节点从树上删去，返回最后得到的森林（一些不相交的树构成的集合）。 | 对于每个待删除的节点，其左右子节点成为新的子树根节点候选，并将该节点与父节点的关系进行移除。|

### ⚪ 树的前序遍历、中序遍历和后序遍历（深度优先搜索）

利用深度优先搜索遍历二叉树的方式有三种：前序遍历、中序遍历和后序遍历。它们对节点访问的顺序有一点不同，其它完全相同。

```python
# 前序遍历先遍历父结点，再遍历左结点，最后遍历右节点
def preorder(root):
    print(root.val)
    preorder(root.left)
    preorder(root.right)
# 对于任意一颗树而言，前序遍历的形式总是
# [ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]

# 中序遍历先遍历左节点，再遍历父结点，最后遍历右节点
def inorder(root):
    inorder(root.left)
    print(root.val)
    inorder(root.right)
# 对于任意一颗树而言，中序遍历的形式总是
# [ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]

# 后序遍历先遍历左节点，再遍历右结点，最后遍历父节点
def postorder(root):
    print(root.val)
    postorder(root.left)
    postorder(root.right)
# 对于任意一颗树而言，后序遍历的形式总是
# [ [左子树的中序遍历结果], [右子树的中序遍历结果], 根节点 ]
```

| 题目 | 题干 | 解法 |
| :---:  |  :---:  |  :---:  |
| [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/) <br> **easy** | 给定一个二叉树的根节点，返回它节点值的中序遍历。递归算法很简单，你可以通过迭代算法完成吗？ | 递归的本质是栈调用，可以通过栈来实现中序遍历。注意入栈的顺序先右再根后左，并优先读取没有子树可以入栈的节点。 |
| [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/) <br> **easy** | 给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 | 前序遍历时传递当前最大深度。 |
| [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) <br> **medium** | 给定一个二叉树的前序遍历和中序遍历，构造二叉树并返回其根节点。 | 在前序遍历数组中从前往后依次取到根节点，对应的去中序数组中确定左子树和右子树的范围。 |
| [106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/) <br> **medium** | 给定一个二叉树的中序遍历和后序遍历，构造二叉树并返回其根节点。 | 在后序遍历数组中从后往前依次取到根节点，对应的去中序数组中确定左子树和右子树的范围。 |
| [144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/) <br> **easy** | 给定一个二叉树的根节点，返回它节点值的前序遍历。递归算法很简单，你可以通过迭代算法完成吗？ | 递归的本质是栈调用，可以通过栈来实现前序遍历。注意入栈的顺序先右后左，保证左子树先遍历。 |
| [145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/) <br> **easy** | 给定一个二叉树的根节点，返回它节点值的后序遍历。递归算法很简单，你可以通过迭代算法完成吗？ | 递归的本质是栈调用，可以通过栈来实现后序遍历。注意入栈的顺序先根再右后左，并优先读取没有子树可以入栈的节点。 |
| [404. 左叶子之和](https://leetcode.cn/problems/sum-of-left-leaves/) <br> **easy** | 给定一个二叉树的根节点，返回所有左叶子之和。 | 前序遍历时传递一个表示是否为左节点的布尔值。 |
| [889. 根据前序和后序遍历构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/) <br> **medium** | 给定一个二叉树的前序遍历和后序遍历，构造二叉树并返回其根节点。 | 在前序遍历数组中从前往后依次取到根节点及左子节点，对应的去后序数组中确定左子树和右子树的范围。 |
| [1026. 节点与其祖先之间的最大差值](https://leetcode.cn/problems/maximum-difference-between-node-and-ancestor/) <br> **medium** | 给定二叉树的根节点，找出存在于不同节点 A 和 B 之间的最大值 $abs(A.val-B.val)$，且 A 是 B 的祖先。 | 前序遍历时传递历史最大值与最小值。 |

### ⚪ 树的层次遍历（广度优先搜索）

可以使用**广度优先搜索**进行层次遍历。注意，不需要使用两个队列来分别存储当前层的节点和下一层的节点，因为在开始遍历一层的节点时，当前队列中的节点数就是当前层的节点数，只要控制遍历这么多节点数，就能保证这次遍历的都是当前层的节点。

```python
from collections import deque
q = deque([root])
while q:
    n = len(q)
    # 处理该层的n个节点
    for i in range(n):
        node = q.popleft()
        q.append(node.left)
        q.append(node.right)
```

| 题目 | 题干 | 解法 |
| :---:  |  :---:  |  :---:  |
| [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/) <br> **easy** | 给定一个二叉树的根节点，检查它是否轴对称。 | 迭代，引入一个队列，把根节点入队两次。每次提取两个结点并比较它们的值，然后将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者检测到树不对称时，该算法结束。 |
| [513. 找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/) <br> **medium** | 给定一个二叉树的根节点，找出该二叉树的最底层最左边节点的值。 | 使用广度优先搜索从右向左搜索，访问到的最后一个元素即为所求。 |
| [637. 二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/) <br> **easy** | 给定一个非空二叉树的根节点，以数组的形式返回每一层节点的平均值。 | 使用广度优先搜索累计每一层的平均值。 |

### ⚪ 二叉查找树

**二叉查找树（Binary Search Tree, BST）**又称为二叉搜索树，是一种特殊的二叉树：对于每个父节点，其左子节点的值小于等于父结点的值，其右子节点的值大于等于父结点的值。

因此对于一个二叉查找树，可以在 $O(n \log n)$ 的时间内查找一个值是否存在：从根节点开始，若当前节点的值大于查找值则向左下走，若当前节点的值小于查找值则向右下走。

同时因为二叉查找树是有序的，对其中序遍历的结果即为排好序的数组。

寻找二叉查找树中的最小元素对应的节点：

```python
minNode = root
while minNode.left:
    minNode = minNode.left
```

| 题目 | 题干 | 解法 |
| :---:  |  :---:  |  :---:  |
| [99. 恢复二叉搜索树](https://leetcode.cn/problems/recover-binary-search-tree/) <br> **medium** | 给定二叉搜索树的根节点，该树中的恰好两个节点的值被错误地交换。请在不改变其结构的情况下恢复这棵树。 | 使用中序遍历二叉查找树，同时设置一个指针记录前一个遍历节点。如果当前节点大于前一个节点的值，说明需要调整次序。如果遍历整个序列过程中只出现了一次次序错误，则交换这两个相邻节点；否则交换两次次序错误的节点。 |
| [109. 有序链表转换二叉搜索树](https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/) <br> **medium** | 给定一个单链表的头节点，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。 | 使用快慢指针搜索链表的中部（若为偶数长度则应取右节点），然后以中部节点为根节点，递归地构造左右子树。 |
| [235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/) <br> **medium** | 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 | 最近公共祖先应满足：左右子树分别包含一个指定节点或根结点为其中一个节点。通过节点的数值关系判断最近公共祖先的位置。 |
| [450. 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/) <br> **medium** | 给定一个二叉搜索树的根节点和一个值，删除二叉搜索树中的该值对应的节点，并保证二叉搜索树的性质不变。 | 递归，分情况讨论：<br> ① 当前节点的值大于目标值：递归左节点 <br> ② 当前节点的值小于目标值：递归右节点 <br> ③.I 当前节点的值等于目标值，且当前节点为叶节点：返回None <br> ③.II 当前节点的值等于目标值，且当前节点不平衡：返回非空子树 <br> ③.III 当前节点的值等于目标值，且当前节点平衡：将当前节点的后继节点（右子树中的最小节点）作为根节点，并从右子树中删除后继节点 |
| [530. 二叉搜索树的最小绝对差](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/) <br> **easy** | 给出一个二叉搜索树的根节点，返回树中任意两不同节点值之间的最小差值。 | 中序遍历，存储上一个节点的指针。 |
| [538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/) <br> **medium** | 给出二叉搜索树的根节点，该树的节点值各不相同，将其转换为累加树，使每个节点的新值等于原树中大于或等于该节点值之和。 | 按照右→根→左的顺序遍历节点。 |
| [897. 递增顺序搜索树](https://leetcode.cn/problems/increasing-order-search-tree/) <br> **easy** | 给定二叉搜索树的根节点，按中序遍历将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。 | 中序遍历，使用哑节点记录根结点。 |
| [653. 两数之和 IV - 输入二叉搜索树](https://leetcode.cn/problems/two-sum-iv-input-is-a-bst/) <br> **easy** | 给定一个二叉搜索树和一个目标结果，判断二叉搜索树中是否存在两个元素的和等于给定的目标结果。 | 解法①：使用任意方法遍历节点，通过哈希集合存储已遍历的节点值。  <br> 解法②： 中序遍历把二叉树转化为有序数组，然后采用双指针搜索目标。 |
| [897. 递增顺序搜索树](https://leetcode.cn/problems/increasing-order-search-tree/) <br> **easy** | 给定二叉搜索树的根节点，按中序遍历将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。 | 中序遍历，使用哑节点记录根结点。 |

### （3）图

图是树的升级版。图通常分为**有向（directed）**或**无向（undirected）**，**有循环（cyclic）**或**无循环（acyclic）**，所有节点**相连（connected）**或**不相连（disconnected）**。树即是一个相连的无向无环图，而另一种很常见的图是有向无环图（**Directed Acyclic Graph，DAG**）。

图通常有两种表示方法。假设图中一共有 $n$ 个节点、$m$ 条边。第一种表示方法是**邻接矩阵（adjacency matrix）**：我们可以建立一个 $n× n$ 的矩阵 $G$，如果第 $i$ 个节点连向第 $j$ 个节点，则 $G[i][j]= 1$，反之为 $0$；如果图是无向的，则这个矩阵一定是对称矩阵，即 $G[i][j] = G[j][i]$。

第二种表示方法是**邻接链表（adjacency list）**：我们可以建立一个大小为 $n$ 的数组，每个位置 $i$ 储存一个数组或者链表，表示第 $i$ 个节点连向的其它节点。

邻接矩阵空间开销比邻接链表大，但是邻接链表不支持快速查找 $i$ 和 $j$ 是否相连，因此两种表示方法可以根据题目需要适当选择。除此之外，我们也可以直接用一个 $m × 2$ 的矩阵储存所有的边。

```python
# 构建无向图的邻接矩阵
graph = [[0]*n for _ in range(n)]
for a, b in edges:
    graph[a][b] = 1
    graph[b][a] = 1

# 构建无向图的邻接链表，适用于元素较多的场合
graph = [[] for _ in range(n)]
for a, b in edges:
    graph[a].append(b)
    graph[b].append(a)
```

| 题目 | 题干 | 解法 |
| :---:  |  :---:  |  :---:  |
| [210. 课程表 II](https://leetcode.cn/problems/is-graph-bipartite/) <br> **medium** | 总共有 n 门课需要选。给定一个数组，其中第i个元素[ai, bi]表示在选修课程 ai 前必须 先选修 bi。返回为了学完所有课程所安排的学习顺序。如果不可能完成所有课程，返回一个空数组。 | **拓扑排序（topological sort）**：有向无环图排序的算法。给定有向无环图中的$N$个节点，把它们排序成一个线性序列；若原图中节点 $i$ 指向节点 $j$，则排序结果中 $i$ 一定在 $j$ 之前。考虑拓扑排序中最前面的节点，该节点一定不会有任何入边。把该节点加入答案中后移除它的所有出边。如果某个相邻节点变成了「没有任何入边的节点」，则把它加入答案，直到答案中包含所有的节点（得到了一种拓扑排序）或者不存在没有入边的节点（图中包含环）。 |
| [785. 判断二分图](https://leetcode.cn/problems/is-graph-bipartite/) <br> **medium** | 存在一个无向图，判断该图是否为二分图。二分图定义：如果能将一个图的节点集合分割成两个独立的子集 A 和 B ，并使图中的每一条边的两个节点一个来自 A 集合，一个来自 B 集合，就将这个图称为二分图。 | **染色法**：任选一个节点给它染成红色，随后将该节点直接相连的所有节点染成绿色；以此类推，直到无向图中的每个节点均被染色。如果染色过程中访问到一个已经染色的节点与将要给它染上的颜色不相同，则该无向图不是二分图。若无向图不一定保证连通，则需要进行多次遍历，直到每一个节点都被染色。 |

## ⚪ 其他数据结构

### （1）前缀和与积分图

一维的前缀和（**prefix sum**），二维的积分图（**integral image**），都是把每个位置之前的一维线段或二维矩形预先存储，方便加速计算。

如果需要对前缀和或积分图的值做寻址，则要存在哈希表里；如果要对每个位置记录前缀和或积分图的值，则可以储存到一维或二维数组里，可以通过动态规划实现。

下面是构造一维前缀和的例子。需要注意前缀和索引$i$的含义是数组前$i$项的和，从前$0$个和到前$n$个和，则数组总的长度是$n+1$。

$$
sums[i] = sums[i-1] + nums[i-1]
$$

```python
# 写法①
sums = [0]
for num in nums:
    sums.append(sums[-1] + num)

# 写法②
sums = list(accumulate(num))
```

下面是构造二维积分图的例子。

$$
\begin{aligned}
sums[i][j] = &sums[i-1][j] + sums[i][j-1] \\
& - sums[i-1][j-1] + nums[i-1][j-1]
\end{aligned}
$$

```python
sums = [[0]*(n+1) for _ in range(m+1)]
for i in range(1, m+1):
   for j in range(1, n+1):
       sums[i][j] = sums[i][j-1]+sums[i-1][j]-sums[i-1][j-1]+nums[i-1][j-1]
```

![](https://pic.imgdb.cn/item/6434b53d0d2dde5777da4c6c.jpg)

| 题目 | 题干 | 解法 |
| :---:  |  :---:  |  :---:  |
| [238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/) <br> **easy** | 给定一个整数数组，返回一个新数组，其中第i个元素等于原数组中除该元素之外其余各元素的乘积。  | 把整数数组转化为前缀积与后缀积的形式。 |
| [303. 区域和检索 - 数组不可变](https://leetcode.cn/problems/range-sum-query-immutable/) <br> **easy** | 给定一个整数数组，计算索引left和right（包含left和right）之间的元素的和。  | 把整数数组转化为前缀和。 |
| [304. 二维区域和检索 - 矩阵不可变](https://leetcode.cn/problems/range-sum-query-2d-immutable/) <br> **medium** | 给定一个二维矩阵，计算其子矩形范围内元素的总和。  | 把二维矩阵转化为积分图。 |
| [560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/) <br> **medium** | 给定一个整数数组和一个整数k，统计该数组中和为k的连续子数组的个数。  | 使用哈希表存储前缀和出现的次数。 |

### （2）并查集

**并查集**（**union-find**）是一种树型的数据结构，用于处理一些不相交集合（**disjoint sets**）的合并及查询问题。

假设存在 $n$ 个节点，我们先将所有节点的父亲标为自己；每次要连接节点 $i$ 和 $j$ 时，可以将 $i$ 的父亲标为 $j$；每次要查询两个节点是否相连时，可以查找 $i$ 和 $j$ 的祖先是否最终为同一个人。

![](https://pic.imgdb.cn/item/6441da040d2dde5777981d89.jpg)

并查集维护一个数组`parent`，数组中维护的是元素的下标索引，这个下标索引指向该元素的父元素。并查集主要有三个功能：
1. 寻找根节点：`find(u)`，也就是判断节点$u$的祖先节点是哪个节点；
2. 将两个节点接入到同一个集合：`union(u, v)`，将两个节点$u,v$连在同一个根节点上；
3. 判断两个节点是否在同一个集合：`same(u, v)`，就是判断两个节点是不是属于同一个根节点。


```python
# 并查集初始化
parent = [for i in range(n)]

# 并查集里寻根
def find(u):
    return u if parent[u] == u else find(parent[u])

# 将 v->u 这条边加入并查集
def union(u, v):
    u, v = find(u), find(v)
    if u == v:
        return
    parent[v] = u

# 判断 u 和 v 是否属于同一个根
def same(u, v):
    return find(u) == find(v) # 注意是find不是parent！！
```

为了加速查找，我们可以使用路径压缩和按秩合并来优化并查集：
- **按秩合并**：秩定义为节点的最大深度。在执行`union(u, v)`时，将秩大的根节点设置为合并后的根节点，避免了树的深度增加（避免后续的节点查询时间长）。
- **路径压缩**：在执行`find(u)`时，当在寻找一个节点的根节点**root**时，直接将该节点的所有长辈节点全部指向根节点**root**。后续寻找这些节点的根节点时可以节省很长一段搜索路径。

```python
parent = [for i in range(n)]
rank = [1]*n # 记录每个节点的秩

def find(u):
    # 路径压缩
    if u != parent[u]:
        parent[u] = find(parent[u])
    return parent[u]

def union(u, v):
    u, v = find(u), find(v)
    if u == v:
        return
    # 按秩合并
    if rank[u] < rank[v]:
        parent[u] = v
    elif rank[u] > rank[v]:
        parent[v] = u
    else:
        parent[v] = u
        rank[u] += 1
```

并查集通常被用于判断节点的**连通性**问题。

| 题目 | 题干 | 解法 |
| :---:  |  :---:  |  :---:  |
| [684. 冗余连接](https://leetcode.cn/problems/implement-trie-prefix-tree/) <br> **medium** | 给定往一棵 n 个节点 (节点值 1～n) 的树中添加一条边后的图。添加的边的两个顶点包含在 1 到 n 中间，且这条附加的边不属于树中已存在的边。找出一条可以删去的边，删除后可使得剩余部分是一个有着 n 个节点的树。  | 通过并查集寻找附加的边。遍历每一条边，边的两个节点如果不在同一个集合，就加入集合。如果边的两个节点出现在同一个集合里，说明两个节点已经连在一起了。 |
| [721. 账户合并](https://leetcode.cn/problems/accounts-merge/) <br> **medium** | 给定一个字符串列表，其中第一个元素是名称，其余元素表示该账户的邮箱地址。合并这些账户：如果两个账户都有一些共同的邮箱地址，则两个账户必定属于同一个人。  | 遍历每个账户下的邮箱，判断该邮箱是否在其他账户下出现。如果两个账户下出现了相同的邮箱，那么将两个账户的连通分量进行合并。最后遍历并查集中每个连通分量，将所有连通分量内部账户的邮箱全部合并。 |
| [839. 相似字符串组](https://leetcode.cn/problems/similar-string-groups/) <br> **hard** | 如果两个字符串相等或其中一个字符串交换两个不同位置的字母后与另一个字符串相等，则称两个字符串相似。给定一个字符串列表，列表中的每个字符串都是其它所有字符串的一个字母异位词，求有多少个相似字符串组。  | 枚举给定序列中的任意一对字符串，检查其是否具有相似性，如果相似，那么就将这对字符串相连。 |
| [990. 等式方程的可满足性](https://leetcode.cn/problems/satisfiability-of-equality-equations/) <br> **medium** | 给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程采用两种不同的形式之一："a==b" 或 "a!=b"。判断是否可以将整数分配给变量名，以便满足所有给定的方程。  | 首先遍历所有的等式，构造并查集。同一个等式中的两个变量属于同一个连通分量。然后遍历所有的不等式。同一个不等式中的两个变量不能属于同一个连通分量。 |
| [1061. 按字典序排列最小的等效字符串](https://leetcode.cn/problems/lexicographically-smallest-equivalent-string/) <br> **medium** | 给定长度相同的两组等价字符串，利用它们的等价信息，找出任意字符串的按字典序排列最小的等价字符串。  | 利用并查集维护任意字符的连通性，对于字符串中的每个字符，将其替换为连通的最小字符。 |
| [1202. 交换字符串中的元素](https://leetcode.cn/problems/smallest-string-with-swaps/) <br> **medium** | 给定一个字符串，以及该字符串中的一些「索引对」数组，表示字符串中的两个索引。任意多次交换数组中任意一对索引处的字符。返回在经过若干次交换后可以变成的按字典序最小的字符串。  | 利用并查集维护任意两点的连通性，将同属一个连通块内的点提取出来，直接排序后放置回其在字符串中的原位置即可。 |


### （3）设计数据结构

在设计复合类型的数据结构时，可以通过列表进行数据存储，从而加速连续选址或删除值；也可以通过哈希字典进行辅助记录或加速寻址。


| 题目 | 题干 | 解法 |
| :---:  |  :---:  |  :---:  |
| [208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/) <br> **medium** | 前缀树是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。实现一个前缀树，包含功能：插入字符串，判断一个字符串或前缀是否存在。  | 建立哈希字典依次存储字符串中的字符，并标记字符串的结尾。 |
| [380. O(1) 时间插入、删除和获取随机元素](https://leetcode.cn/problems/insert-delete-getrandom-o1/) <br> **medium** | 实现RandomizedSet类：以O(1)时间复杂度插入、移除元素，以及随机返回现有集合中的一项。  | 变长数组（可以在 O(1) 的时间内完成获取随机元素操作）中存储元素，哈希表（可以在 O(1) 的时间内完成插入和删除操作）中存储每个元素在变长数组中的下标。 |
| [432. 全 O(1) 的数据结构](https://leetcode.cn/problems/all-oone-data-structure/) <br> **hard** | 设计一个用于存储字符串计数的数据结构，并能够返回计数最小和最大的字符串。  | 使用一个哈希字典存储“字符串：计数值”；使用一个**TreeMap**维护“计数值：字符串”。 |
| [1172. 餐盘栈](https://leetcode.cn/problems/dinner-plate-stacks/) <br> **hard** | 实现一个叫「餐盘」的类：把无限数量的栈排成一行，每个栈的的最大容量都相同。包含功能：将给出的正整数推入从左往右第一个没有满的栈；弹出从右往左第一个非空栈顶部的值；弹出给定编号的栈顶部的值。  | 使用数组模拟栈，使用有序列表维护未满栈和未空栈的编号。 |