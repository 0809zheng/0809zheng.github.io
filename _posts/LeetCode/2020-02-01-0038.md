---
layout: post
title: 'LeetCode #38 Count and Say'
date: 2020-02-01
author: 郑之杰
cover: ''
tags: LeetCode
---

> LeetCode 每日一题 #38.[Count and Say](https://leetcode-cn.com/problems/count-and-say/)

## 题目
The count-and-say sequence is the sequence of integers with the first five terms as following:

```
1.     1
2.     11
3.     21
4.     1211
5.     111221
```

- 1 is read off as "one 1" or 11.
- 11 is read off as "two 1s" or 21.
- 21 is read off as "one 2, then one 1" or 1211.

Given an integer n where 1 ≤ n ≤ 30, generate the $n^{th}$ term of the count-and-say sequence. You can do so recursively, in other words from the previous member read off the digits, counting the number of digits in groups of the same digit.

Note: Each term of the sequence of integers will be represented as a string.

**Example 1：**
```
Input: 1
Output: "1"
Explanation: This is the base case.
```

**Example 2：**
```
Input: 4
Output: "1211"
Explanation: For n = 3 the term was "21" in which we have two groups "2" and "1", "2" can be read as "12" which means frequency = 1 and value = 2, the same way "1" is read as "11", so the answer is the concatenation of "12" and "11" which is "1211".
```

## 思路
递归

## 解答
```
class Solution:
    def countAndSay(self, n: int) -> str:
        if n == 1:
            return '1'
        else:
            s = self.countAndSay(n-1)
            count, temp, say = 1, '', ''
            for i in range(len(s)):
                if s[i] == temp:
                    count += 1
                else:
                    if temp == '':
                        temp = s[i]
                        continue
                    say += str(count) + temp
                    temp, count = s[i], 1
            say += str(count) + temp
            return say
```

## 复杂度
- 时间复杂度：$O(n!)$
- 空间复杂度：$O(n)$