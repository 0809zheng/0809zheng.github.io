---
layout: post
title: 'LeetCode #63 Unique Paths II'
date: 2020-02-01
author: 郑之杰
cover: ''
tags: LeetCode
---

> LeetCode 每日一题 #63.[Unique Paths II](https://leetcode-cn.com/problems/unique-paths-ii/)

## 题目
A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

Now consider if some obstacles are added to the grids. How many unique paths would there be?

![](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)

An obstacle and empty space is marked as 1 and 0 respectively in the grid.

**Note:** m and n will be at most 100.

**Example 1:**
```
Input:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
Output: 2
Explanation:
There is one obstacle in the middle of the 3x3 grid above.
There are two ways to reach the bottom-right corner:
1. Right -> Right -> Down -> Down
2. Down -> Down -> Right -> Right
```

## 思路
动态规划：

- **状态定义：**

$dp\[i\]\[j\]$:表示从左上角走到位置$(i,j)$处有多少种走法。

- **转移方程：**

$$ dp[i][j] = \begin{cases} dp[i-1][j]+dp[i][j-1], & obstacleGrid[i][j]=0 \\ 0, & obstacleGrid[i][j]=1 \end{cases} $$

- **初始状态：**

$dp$所有元素赋值为0，$dp\[1\]\[1\]=1$

- **返回值：**

返回$dp\[m\]\[n\]$。

## 解答
```
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        if obstacleGrid == []:
            return 0
        if obstacleGrid == [[]]:
            return 1

        m, n =len(obstacleGrid), len(obstacleGrid[0])
        dp = [[0]*(n+1) for _ in range(m+1)]

        for i in range(1, m+1):
            for j in range(1, n+1):
                if obstacleGrid[i-1][j-1] == 0:
                    if i == j == 1:
                        dp[1][1] = 1
                    else:
                        dp[i][j] = dp[i-1][j]+dp[i][j-1]
        return dp[m][n]
```

## 复杂度
- 时间复杂度：$O(mn)$
- 空间复杂度：$O(mn)$